<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WebAssembly: the common tongue of the Web, a Go approach | Mago's Blog</title><meta name=keywords content="Go,Technical,WebAssembly"><meta name=description content="A brief introduction to WebAssembly and its relation to Go, with a hands-on example"><meta name=author content="Mago"><link rel=canonical href=https://blog.o-mago.com/posts/webassembly-the-common-tongue-of-the-web/><meta name=google-site-verification content="G-FNV8YL5XRB"><link crossorigin=anonymous href=/assets/css/stylesheet.4d2dbf7caeee89bc7396fdb4eb572ee4e4bc0d06d9c1599d5474570674da50fa.css integrity="sha256-TS2/fK7uibxzlv2061cu5OS8DQbZwVmdVHRXBnTaUPo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.o-mago.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.o-mago.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.o-mago.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.o-mago.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.o-mago.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.o-mago.com/posts/webassembly-the-common-tongue-of-the-web/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FNV8YL5XRB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FNV8YL5XRB")</script><meta property="og:url" content="https://blog.o-mago.com/posts/webassembly-the-common-tongue-of-the-web/"><meta property="og:site_name" content="Mago's Blog"><meta property="og:title" content="WebAssembly: the common tongue of the Web, a Go approach"><meta property="og:description" content="A brief introduction to WebAssembly and its relation to Go, with a hands-on example"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-18T11:00:00-03:00"><meta property="article:modified_time" content="2025-07-18T11:00:00-03:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Technical"><meta property="article:tag" content="WebAssembly"><meta property="og:image" content="https://blog.o-mago.com/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.o-mago.com/logo.png"><meta name=twitter:title content="WebAssembly: the common tongue of the Web, a Go approach"><meta name=twitter:description content="A brief introduction to WebAssembly and its relation to Go, with a hands-on example"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"WebAssembly: the common tongue of the Web, a Go approach","item":"https://blog.o-mago.com/posts/webassembly-the-common-tongue-of-the-web/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebAssembly: the common tongue of the Web, a Go approach","name":"WebAssembly: the common tongue of the Web, a Go approach","description":"A brief introduction to WebAssembly and its relation to Go, with a hands-on example","keywords":["Go","Technical","WebAssembly"],"articleBody":"Today I‚Äôll talk a little bit about frontend (don‚Äôt be mad ü•∫üôè). First, I‚Äôll briefly introduce what WebAssembly is, and then how it relates to Go. I‚Äôll probably write more about this subject, but first I want to make this introduction to get everyone on the same page. The idea of this blog is not to post gigantic articles, but smaller ones every week (I‚Äôll try my best üòâ) that can talk to each other.\nI presented on this subject at GopherCon Latam 2024. If you prefer video and understand Portuguese, here is a link.\nThe history Grab your popcorn, it‚Äôs history time!\nBefore WebAssembly was born, a wild battle was raging on the internet. The year was 2010, and Google and Mozilla were deciding what the future of the web would look like.\nIn 2008, Google created the Native Client (NaCl), a way to run a subset of native machine code (x86 for instance) in a sandbox in your browser. The code ran at great speed, but it couldn‚Äôt access the existing Web API because everything was running in a separate process, so you had to deal with a plugin API, like Flash used to do.\nMozilla started a new project called Emscripten in 2011, a compiler from C and C++ (or any LLVM-supported language) into JavaScript (at that time). It‚Äôs web-friendly because, at the end of the day, it‚Äôs JS and can communicate with the Web API. But it‚Äôs bad for the same reason, because it‚Äôs JS ü§™, so it‚Äôs slow. Then they decided to create asm.js, a subset of JS with the capabilities of some AOT (Ahead of Time) compilation, more reliable and consistent optimizations than the JIT (just in time) compilation. This enabled asm.js to run faster than normal JS code, but it was still JavaScript, so it couldn‚Äôt compete with binary code.\nIn 2013, Google and Mozilla put their differences aside and started working together, collaborating, and in 2015 NaCl and asm.js had a baby called WebAssembly:\nIt can interact with the DOM and Web API It‚Äôs not JavaScript; it‚Äôs binary code that runs in a VM (to be portable) If you want to know more about this story in detail, take a look at this presentation by Alon Zakai, the creator of Emscripten and co-creator of WebAssembly.\nWebAssembly When we break the term into Web and Assembly, we might think it is a way to run Assembly on the Web, in your browser, right? That‚Äôs (almost) right; it‚Äôs actually a low-level assembly-like code.\nWebAssembly (abbreviated¬†Wasm) is a binary instruction format for a stack-based virtual machine.\nThis is quite enlightening. Now we know that WebAssembly is a programming language (a low-level one), so it means you can write it, but it‚Äôs not meant to be written by you (usually). It was made to be compiled from other languages like Go, Rust, C, etc.\nAnd the idea here is not for WebAssembly to kill JavaScript (I wish üòÖ), it‚Äôs for them to work together, to be complementary. You can take advantage of JS flexibility to work with your webpage‚Äôs common usability, simple components, texts, inputs, etc., and leave the hard work to your WASM code when you need to deal with complex algorithms, CPU or GPU-heavy processes.\nWebAssembly is especially useful for porting games to your browser; Unity uses it to export games for the web. Tools like Figma took advantage of WASM, writing their code in C++ and running close to native speed in the browser.\nBut it doesn‚Äôt stop there; WASM is being used for much more. Although it was conceived with browsers in mind, at the end of the day it runs on a VM‚Äîthe browser just happens to have a runtime that runs it, like V8 on Chrome.\nThat‚Äôs when WASI (WebAssembly System Interface) comes into play in 2019, a standardization of APIs for WebAssembly to deal with systems outside the browser, like network stuff and filesystems. In a nutshell, you can run your CLIs and backend services as WASM binaries. To do this, you need a runtime, and there are lots of options like wazero and wasmtime.\nYou can even have one of these runtimes inside your Kubernetes cluster and, instead of using containers, you can run WebAssembly binaries or run WASM files inside your containers. There‚Äôs a CNCF project called wasmcloud that can orchestrate your WASM services. It‚Äôs still uncertain what the future holds; some say WASM will replace containers as we know them because they‚Äôre fast to start, smaller than container images, and secure because they run isolated from the host in their own sandbox. But at the same time, WASM code is limited to the functionalities standardized by WASI, and not all languages have compilers to WASM.\nAnother use case that I really like is tools where you need SDKs for different languages. You can create the core functionalities in Rust, for example, and compile to WASM. Then, instead of recreating the whole SDK in different languages, you just create the ‚Äúinterfaces‚Äù for that specific language that call all the WASM logic from that binary you compiled. A good example is some of the Flipt‚Äôs SDKs like Go, JavaScript, and React. They have a pretty interesting article about this choice.\nHence the title of the post, it‚Äôs like a common tongue for the programming languages to communicate between them and with the web itself\nGo + WebAssembly I hope you now know at least a little bit about what WebAssembly is and what it‚Äôs capable of. Now let‚Äôs talk about Go‚Äôs support for WebAssembly.\nIt was introduced experimentally in 2018 with Go 1.11, meaning it got a WASM compiler. This port evolved, and in 2023 WASI support was introduced experimentally in Go 1.21. And if you pay attention to the release notes, it‚Äôs common for some new Go versions to have a WebAssembly section with some improvements, like binary size.\nTalking about the binary size of WASM, usually Golang ones are bigger and slower than Rust WASM binaries, for instance. This is due to having to include all the goroutine runtime, garbage collector, maps, and other Golang stuff into it. Like I said, it has improved a lot. Another thing that could help reduce size and improve performance would be targeting WASM runtimes with garbage collector extension. Since 2023, Chrome already supports WASM GC by default. This way, the Go compiler wouldn‚Äôt need to include the GC in the binary, so it would be smaller‚Ä¶\nBut we have an option for smaller WASM binaries using Golang; it‚Äôs called TinyGo, an embedded systems and WebAssembly-focused compiler based on LLVM, implementing lots of optimizations, removing some Go runtime capabilities, not supporting some Go standard libraries, and using a different minimal garbage collector.\nWhat should you use for WASM? It‚Äôs up to you and your project. If you want to port already written standard Go code to WASM, maybe it will be better to just compile it using the Go tool. If it‚Äôs a new app, simpler and that must be as small as possible, TinyGo is the way. If you have the chance, test both and compare them; performance may vary depending on the tasks you are dealing with.\nHands on For these examples, I‚Äôm using Go 1.24.5 and TinyGo 0.38.0:\nLet‚Äôs do a simple example just to help you understand things a little bit more. I‚Äôll create a simple Go code just to print ‚ÄúWebAssembly‚Äù in a main.go file. The idea here is for our browser to print this message at the end:\npackage main func main() { println(\"WebAssembly\") } The Go tool already has the built-in capability of compiling to WASM. In order to compile it to run in our browser, we need two steps. I‚Äôve created an assets folder that will contain all our files to be served by our file server. First, build our binary:\nGOOS=js GOARCH=wasm go build -o ./assets/main.wasm Second, we need a supporting file (it‚Äôs already on our machine as soon as we install Go) that allows us to communicate with our JavaScript code, so:\ncp \"$(go env GOROOT)/libs/wasm/wasm_exec.js\" ./assets Then we create an html file that will import both files with the following content:\n\u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e \u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"main.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e \u003c/html\u003e Lastly, I will create a simple Go file server pointing to our assets folder:\npackage main import ( \"net/http\" ) func main() { http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"./assets\"))) } And as expected, the console printed our message:\nCongratulations, you have just run your first Go code in the browser (if you have never used WebAssembly with Go before, of course üòÑ).\nI‚Äôve talked about TinyGo, so let‚Äôs compile our WASM file with it. The main.go will not change, nor will our server or HTML. The only difference here is the build commands:\nGOOS=js GOARCH=wasm tinygo build -o ./assets/main.wasm And the JS support file is located in a different place. The location might be different depending on your OS and how you installed TinyGo, but in my case I installed it using Homebrew, so the command to copy the file is:\ncp \"/opt/homebrew/Cellar/tinygo/0.38.0/targets/wasm_exec.js\" ./assets/wasm_exec.js The result is the same, but the file size is quite different. Renaming them to go.wasm and tiny-go.wasm:\nWe can see that the TinyGo one is only 95K and the Go one is 1.5MB, which means 15 times bigger üò±. This is not a good example to dive into performance (maybe in another post), but choose wisely üßô‚Äç‚ôÇÔ∏è\nReal world example Ok, this is interesting, but it‚Äôs just ‚ÄúHello World‚Äù code‚Äînot so exciting, right? Remember I talked about how WebAssembly is interesting for porting games to the web? Well‚Ä¶\nAt GopherCon 2024, where I presented a WebAssembly talk, there was another speaker from Varginha, a Brazilian city known for the most notorious alien appearance in Brazil, Matheus Mina (‚Äúseus cabelo √© da hora‚Äù, as Mamonas Assassinas would say üòÇ). We were talking in the VIP room, and he was developing a game using Ebitengine. It‚Äôs that game where you have to order the numbers by sliding the pieces. We talked, and I decided to port his game to the web, so I forked it, added touch screen support, compiled it to WASM, and uploaded it to my website using Github Pages.\nHere‚Äôs the code and the game can be played at this address.\nWhat about you? Did you know about WebAssembly? Have you worked with it before? What are your thoughts on the future of WASM and its integration with Go?\n","wordCount":"1756","inLanguage":"en","image":"https://blog.o-mago.com/logo.png","datePublished":"2025-07-18T11:00:00-03:00","dateModified":"2025-07-18T11:00:00-03:00","author":{"@type":"Person","name":"Mago"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.o-mago.com/posts/webassembly-the-common-tongue-of-the-web/"},"publisher":{"@type":"Organization","name":"Mago's Blog","logo":{"@type":"ImageObject","url":"https://blog.o-mago.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.o-mago.com/ class=site-title><img src=/logo.png width=80 alt="Mago's Blog" style=vertical-align:middle></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.o-mago.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://blog.o-mago.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.o-mago.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.o-mago.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://o-mago.com title="About Me"><span>About Me</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.o-mago.com/>Home</a></div><h1 class="post-title entry-hint-parent">WebAssembly: the common tongue of the Web, a Go approach</h1><div class=post-description>A brief introduction to WebAssembly and its relation to Go, with a hands-on example</div><div class=post-meta><span title='2025-07-18 11:00:00 -0300 -03'>July 18, 2025</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;1756 words&nbsp;¬∑&nbsp;Mago<div class=post-list-tags><a href=/tags/go>Go</a>&nbsp;¬∑&nbsp;<a href=/tags/technical> Technical</a>&nbsp;¬∑&nbsp;<a href=/tags/webassembly> WebAssembly</a></div></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-history aria-label="The history">The history</a></li><li><a href=#webassembly aria-label=WebAssembly>WebAssembly</a></li><li><a href=#go--webassembly aria-label="Go + WebAssembly">Go + WebAssembly</a></li><li><a href=#hands-on aria-label="Hands on">Hands on</a></li><li><a href=#real-world-example aria-label="Real world example">Real world example</a></li></ul></div></details></div><div class=post-content><p>Today I‚Äôll talk a little bit about frontend (don‚Äôt be mad ü•∫üôè). First, I‚Äôll briefly introduce what WebAssembly is, and then how it relates to Go. I‚Äôll probably write more about this subject, but first I want to make this introduction to get everyone on the same page. The idea of this blog is not to post gigantic articles, but smaller ones every week (I‚Äôll try my best üòâ) that can talk to each other.</p><p>I presented on this subject at GopherCon Latam 2024. If you prefer video and understand Portuguese, here is a <a href="https://www.youtube.com/watch?v=rSy9Oe-5Cxs">link</a>.</p><h2 id=the-history>The history<a hidden class=anchor aria-hidden=true href=#the-history>#</a></h2><p>Grab your popcorn, it‚Äôs history time!</p><p>Before <a href=https://webassembly.org/>WebAssembly</a> was born, a wild battle was raging on the internet. The year was 2010, and Google and Mozilla were deciding what the future of the web would look like.</p><p>In 2008, Google created the <code>Native Client</code> (NaCl), a way to run a subset of native machine code (x86 for instance) in a sandbox in your browser. The code ran at great speed, but it couldn‚Äôt access the existing Web API because everything was running in a separate process, so you had to deal with a plugin API, like Flash used to do.</p><p>Mozilla started a new project called <code>Emscripten</code> in 2011, a compiler from C and C++ (or any LLVM-supported language) into JavaScript (at that time). It‚Äôs web-friendly because, at the end of the day, it‚Äôs JS and can communicate with the Web API. But it‚Äôs bad for the same reason, because it‚Äôs JS ü§™, so it‚Äôs slow. Then they decided to create <code>asm.js</code>, a subset of JS with the capabilities of some <code>AOT</code> (Ahead of Time) compilation, more reliable and consistent optimizations than the <code>JIT</code> (just in time) compilation. This enabled asm.js to run faster than normal JS code, but it was still JavaScript, so it couldn‚Äôt compete with binary code.</p><p>In 2013, Google and Mozilla put their differences aside and started working together, collaborating, and in 2015 <code>NaCl</code> and <code>asm.js</code> had a baby called <code>WebAssembly</code>:</p><ul><li>It can interact with the DOM and Web API</li><li>It‚Äôs not JavaScript; it‚Äôs binary code that runs in a VM (to be portable)</li></ul><p>If you want to know more about this story in detail, take a look at this <a href="https://www.youtube.com/watch?v=6r0NKEQqkz0">presentation</a> by <a href=https://kripken.github.io/blog/about/>Alon Zakai</a>, the creator of Emscripten and co-creator of WebAssembly.</p><h2 id=webassembly>WebAssembly<a hidden class=anchor aria-hidden=true href=#webassembly>#</a></h2><p>When we break the term into Web and Assembly, we might think it is a way to run Assembly on the Web, in your browser, right? That‚Äôs (almost) right; it‚Äôs actually a low-level assembly-like code.</p><blockquote><p>WebAssembly (abbreviated¬†<em>Wasm</em>) is a binary instruction format for a stack-based virtual machine.</p></blockquote><p>This is quite enlightening. Now we know that WebAssembly is a programming language (a low-level one), so it means you can write it, but it‚Äôs not meant to be written by you (usually). It was made to be compiled from other languages like Go, Rust, C, etc.</p><p>And the idea here is not for WebAssembly to kill JavaScript (I wish üòÖ), it‚Äôs for them to work together, to be complementary. You can take advantage of JS flexibility to work with your webpage‚Äôs common usability, simple components, texts, inputs, etc., and leave the hard work to your WASM code when you need to deal with complex algorithms, CPU or GPU-heavy processes.</p><p>WebAssembly is especially useful for porting games to your browser; Unity uses it to export games for the web. Tools like <a href=https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/>Figma</a> took advantage of WASM, writing their code in C++ and running close to native speed in the browser.</p><p>But it doesn‚Äôt stop there; WASM is being used for much more. Although it was conceived with browsers in mind, at the end of the day it runs on a VM‚Äîthe browser just happens to have a runtime that runs it, like V8 on Chrome.</p><p>That‚Äôs when <a href=https://wasi.dev/>WASI</a> (WebAssembly System Interface) comes into play in 2019, a standardization of APIs for WebAssembly to deal with systems outside the browser, like network stuff and filesystems. In a nutshell, you can run your CLIs and backend services as WASM binaries. To do this, you need a runtime, and there are lots of options like <a href=https://wazero.io/>wazero</a> and <a href=https://github.com/bytecodealliance/wasmtime>wasmtime</a>.</p><p>You can even have one of these runtimes inside your Kubernetes cluster and, instead of using containers, you can run WebAssembly binaries or run WASM files inside your containers. There‚Äôs a CNCF project called <a href=https://wasmcloud.com/>wasmcloud</a> that can orchestrate your WASM services. It‚Äôs still uncertain what the future holds; some say WASM will replace containers as we know them because they‚Äôre fast to start, smaller than container images, and secure because they run isolated from the host in their own sandbox. But at the same time, WASM code is limited to the functionalities standardized by WASI, and not all languages have compilers to WASM.</p><p>Another use case that I really like is tools where you need SDKs for different languages. You can create the core functionalities in Rust, for example, and compile to WASM. Then, instead of recreating the whole SDK in different languages, you just create the ‚Äúinterfaces‚Äù for that specific language that call all the WASM logic from that binary you compiled. A good example is some of the <a href=https://flipt.io/>Flipt‚Äôs</a> SDKs like Go, JavaScript, and React. They have a pretty interesting article about this <a href=https://blog.flipt.io/from-ffi-to-wasm>choice</a>.</p><p>Hence the title of the post, it&rsquo;s like a common tongue for the programming languages to communicate between them and with the web itself</p><h2 id=go--webassembly>Go + WebAssembly<a hidden class=anchor aria-hidden=true href=#go--webassembly>#</a></h2><p>I hope you now know at least a little bit about what WebAssembly is and what it‚Äôs capable of. Now let‚Äôs talk about Go‚Äôs support for WebAssembly.</p><p>It was introduced experimentally in 2018 with Go 1.11, meaning it got a WASM compiler. This port evolved, and in 2023 WASI support was introduced experimentally in Go 1.21. And if you pay attention to the release notes, it‚Äôs common for some new Go versions to have a WebAssembly section with some improvements, like binary size.</p><p>Talking about the binary size of WASM, usually Golang ones are bigger and slower than Rust WASM binaries, for instance. This is due to having to include all the goroutine runtime, garbage collector, maps, and other Golang stuff into it. Like I said, it has improved a lot. Another thing that could help reduce size and improve performance would be targeting WASM runtimes with <a href=https://github.com/WebAssembly/gc>garbage collector</a> extension. Since 2023, <a href=https://developer.chrome.com/blog/wasmgc>Chrome already supports WASM GC by default</a>. This way, the Go compiler wouldn‚Äôt need to include the GC in the binary, so it would be smaller‚Ä¶</p><p>But we have an option for smaller WASM binaries using Golang; it‚Äôs called <a href=https://tinygo.org/>TinyGo</a>, an embedded systems and WebAssembly-focused compiler based on LLVM, implementing lots of optimizations, removing some Go runtime capabilities, not supporting some Go standard libraries, and using a different minimal garbage collector.</p><p>What should you use for WASM? It‚Äôs up to you and your project. If you want to port already written standard Go code to WASM, maybe it will be better to just compile it using the Go tool. If it‚Äôs a new app, simpler and that must be as small as possible, TinyGo is the way. If you have the chance, test both and compare them; performance may vary depending on the tasks you are dealing with.</p><h2 id=hands-on>Hands on<a hidden class=anchor aria-hidden=true href=#hands-on>#</a></h2><p>For these examples, I‚Äôm using <code>Go 1.24.5</code> and <code>TinyGo 0.38.0</code>:</p><p>Let‚Äôs do a simple example just to help you understand things a little bit more. I‚Äôll create a simple Go code just to print ‚ÄúWebAssembly‚Äù in a <code>main.go</code> file. The idea here is for our browser to print this message at the end:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;WebAssembly&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The Go tool already has the built-in capability of compiling to WASM. In order to compile it to run in our browser, we need two steps. I‚Äôve created an <code>assets</code> folder that will contain all our files to be served by our file server. First, build our binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>GOOS</span><span class=p>=</span><span class=nx>js</span> <span class=nx>GOARCH</span><span class=p>=</span><span class=nx>wasm</span> <span class=k>go</span> <span class=nx>build</span> <span class=o>-</span><span class=nx>o</span> <span class=p>.</span><span class=o>/</span><span class=nx>assets</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=nx>wasm</span>
</span></span></code></pre></div><p>Second, we need a supporting file (it‚Äôs already on our machine as soon as we install Go) that allows us to communicate with our JavaScript code, so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>cp</span> <span class=s>&#34;$(go env GOROOT)/libs/wasm/wasm_exec.js&#34;</span> <span class=p>.</span><span class=o>/</span><span class=nx>assets</span>
</span></span></code></pre></div><p>Then we create an <code>html</code> file that will import both files with the following content:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>&lt;</span><span class=nx>html</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nx>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=nx>meta</span> <span class=nx>charset</span><span class=p>=</span><span class=s>&#34;utf-8&#34;</span><span class=o>/</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=nx>script</span> <span class=nx>src</span><span class=p>=</span><span class=s>&#34;wasm_exec.js&#34;</span><span class=p>&gt;&lt;</span><span class=o>/</span><span class=nx>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=nx>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=kd>const</span> <span class=k>go</span> <span class=p>=</span> <span class=nx>new</span> <span class=nf>Go</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=nx>WebAssembly</span><span class=p>.</span><span class=nf>instantiateStreaming</span><span class=p>(</span><span class=nf>fetch</span><span class=p>(</span><span class=s>&#34;main.wasm&#34;</span><span class=p>),</span> <span class=k>go</span><span class=p>.</span><span class=nx>importObject</span><span class=p>).</span><span class=nf>then</span><span class=p>((</span><span class=nx>result</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>go</span><span class=p>.</span><span class=nf>run</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>instance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=o>/</span><span class=nx>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=o>/</span><span class=nx>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nx>body</span><span class=p>&gt;&lt;</span><span class=o>/</span><span class=nx>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=o>/</span><span class=nx>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Lastly, I will create a simple Go file server pointing to our <code>assets</code> folder:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nf>FileServer</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>Dir</span><span class=p>(</span><span class=s>&#34;./assets&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And as expected, the console printed our message:</p><p><img alt="Console outputing &lsquo;WebAssembly&rsquo;" loading=lazy src=/webassembly-the-common-tongue-of-the-web/console.png></p><p>Congratulations, you have just run your first Go code in the browser (if you have never used WebAssembly with Go before, of course üòÑ).</p><p>I‚Äôve talked about TinyGo, so let‚Äôs compile our WASM file with it. The <code>main.go</code> will not change, nor will our server or HTML. The only difference here is the build commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>GOOS</span><span class=p>=</span><span class=nx>js</span> <span class=nx>GOARCH</span><span class=p>=</span><span class=nx>wasm</span> <span class=nx>tinygo</span> <span class=nx>build</span> <span class=o>-</span><span class=nx>o</span> <span class=p>.</span><span class=o>/</span><span class=nx>assets</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=nx>wasm</span>
</span></span></code></pre></div><p>And the JS support file is located in a different place. The location might be different depending on your OS and how you installed TinyGo, but in my case I installed it using Homebrew, so the command to copy the file is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>cp</span> <span class=s>&#34;/opt/homebrew/Cellar/tinygo/0.38.0/targets/wasm_exec.js&#34;</span> <span class=p>.</span><span class=o>/</span><span class=nx>assets</span><span class=o>/</span><span class=nx>wasm_exec</span><span class=p>.</span><span class=nx>js</span>
</span></span></code></pre></div><p>The result is the same, but the file size is quite different. Renaming them to <code>go.wasm</code> and <code>tiny-go.wasm</code>:</p><p><img alt="File size comparison" loading=lazy src=/webassembly-the-common-tongue-of-the-web/file-size.png></p><p>We can see that the TinyGo one is only 95K and the Go one is 1.5MB, which means 15 times bigger üò±. This is not a good example to dive into performance (maybe in another post), but choose wisely üßô‚Äç‚ôÇÔ∏è</p><h2 id=real-world-example>Real world example<a hidden class=anchor aria-hidden=true href=#real-world-example>#</a></h2><p>Ok, this is interesting, but it‚Äôs just ‚ÄúHello World‚Äù code‚Äînot so exciting, right? Remember I talked about how WebAssembly is interesting for porting games to the web? Well‚Ä¶</p><p>At GopherCon 2024, where I presented a WebAssembly talk, there was another speaker from Varginha, a Brazilian city known for the most notorious alien appearance in Brazil, <a href=https://mfbmina.dev/>Matheus Mina</a> (‚Äúseus cabelo √© da hora‚Äù, as Mamonas Assassinas would say üòÇ). We were talking in the VIP room, and he was developing a game using <a href=https://ebitengine.org/>Ebitengine</a>. It‚Äôs that game where you have to order the numbers by sliding the pieces. We talked, and I decided to port his game to the web, so I forked it, added touch screen support, compiled it to WASM, and uploaded it to my website using Github Pages.</p><p>Here‚Äôs the <a href=https://github.com/o-mago/puzzle>code</a> and the game can be played at this <a href=https://o-mago.github.io/puzzle/>address</a>.</p><p>What about you? Did you know about WebAssembly? Have you worked with it before? What are your thoughts on the future of WASM and its integration with Go?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.o-mago.com/tags/go/>Go</a></li><li><a href=https://blog.o-mago.com/tags/technical/>Technical</a></li><li><a href=https://blog.o-mago.com/tags/webassembly/>WebAssembly</a></li></ul><nav class=paginav><a class=next href=https://blog.o-mago.com/posts/concurrent-code-testing-with-synctest-bubbles-in-go/><span class=title>Next ¬ª</span><br><span>Concurrent code testing with synctest bubbles in Go</span></a></nav><ul class=share-buttons>Share:<li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on x" href="https://x.com/intent/tweet/?text=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach&amp;url=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f&amp;hashtags=Go%2cTechnical%2cWebAssembly"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f&amp;title=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach&amp;summary=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach&amp;source=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f&title=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on whatsapp" href="https://api.whatsapp.com/send?text=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach%20-%20https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on telegram" href="https://telegram.me/share/url?text=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach&amp;url=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share WebAssembly: the common tongue of the Web, a Go approach on ycombinator" href="https://news.ycombinator.com/submitlink?t=WebAssembly%3a%20the%20common%20tongue%20of%20the%20Web%2c%20a%20Go%20approach&u=https%3a%2f%2fblog.o-mago.com%2fposts%2fwebassembly-the-common-tongue-of-the-web%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=o-mago/blog issue-term=pathname label=Comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>¬© Alexandre Cabral</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>