[{"content":"Let\u0026rsquo;s talk about why Go is so interesting and why I love it!\nIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\n‚ÄúGo‚Äù by Pearl Jam, ‚ÄúGo‚Äù by Blink-182, ‚ÄúGo‚Äù by Indigo Girls, ‚ÄúGo‚Äù by Kelly Clarkson, \u0026ldquo;Go\u0026rdquo; by The Smashing Pumpkins, \u0026ldquo;Go\u0026rdquo; by Def Leppard, \u0026ldquo;Go Go Go\u0026rdquo; by Chuck Berry, ‚ÄúHere I Go Again‚Äù by Whitesnake, ‚ÄúGo All the Way‚Äù by Raspberries, ‚ÄúGo Your Own Way‚Äù by Fleetwood Mac ‚Ä¶ and the list goes on!\nAfter some consideration, I found out I had lost lots of time searching and listening to songs, and I decided to go ü§≠ with The Clash.\nBut it fits perfectly with the theme. I‚Äôm also a mentor at ADPList, and many of my mentees ask me this question from the title. Ok, not exactly like that, but like ‚ÄúShould I learn Go?‚Äù or ‚ÄúWhy do you like Go?‚Äù\nThe first question is hard to answer, but as a senior engineer, I have the answer: ‚ÄúIt depends.‚Äù Usually, I start asking, not answering, because it depends on each one\u0026rsquo;s reality. I will not dive into this question today (maybe in another post). Today I want to talk about the second one; maybe it helps you reflect on the first one and clear things up for you, maybe not.\nFirst I want to tell my story quickly: how I ended up working with Go, when it started and why I chose to keep going.\nHow it started My first contact with Golang was on a cold night (not that cold, this is Brazil) in September 2020. I was working with JavaScript at that time, I was unhappy (of course, it‚Äôs JS ü§™) and wanted to change jobs. A friend of mine was working in a company using Go and said they were looking for engineers, and wanted to refer me. I didn‚Äôt know Go at the time (just by name), but he said the language was great. I was unsure, but I accepted it and started the selection process.\nThe first step was a LeetCode-like challenge, but it wasn‚Äôt mandatory to use Go. But I wanted to show ‚ÄúI‚Äôm a fast learner,‚Äù so I took one day to study the documentation and did some basic LeetCode with it. I took the test the next day and passed. At that point, I knew I wasn‚Äôt that fast; actually, the language is ‚Äúfast learnable.‚Äù\nThese were the first characteristics of the language that I noticed:\n‚ÄúIt is fast to learn‚Äù ‚ÄúIt has amazing and intuitive documentation‚Äù At that point, I was convinced to give it a try if I got the job.\nI got the job, and then the more I dived into the language, tools, and the community, the more I fell in love with it. ‚ù§Ô∏è\nSo let‚Äôs break into these and other reasons why I fell in love.\nGreat Documentation Why is the documentation great?\nIt‚Äôs meant for learners. When you enter the Go documentation webpage, you don‚Äôt see lots of texts and references, etc. You see lots of links to resources for learning, tutorials, examples, good practices, guidelines, and explanations of the internals. It has resources for starters and for those who want to dive into the internals of Go, like how the garbage collector works. They make it easy for you to start using, but they want you to understand how Go works‚Äîreally understand what you are doing.\nOne of the main parts is the Learn Go section. It‚Äôs so amazing; it‚Äôs where I first learned Go, and that‚Äôs my suggestion to all my mentees and everyone that asks. I‚Äôm not a video tutorial fan, so I tend to prefer written material.\nIt tells you everything very straightforwardly, starting with how to install. Then you have the amazing Tour of Go, where it will teach you all the basics with split sections and interactive examples for you to run using the Go Playground. It‚Äôs great because many people get afraid when they see lots of texts, without a certain order‚Äîthey freeze. The ‚ÄúTour of Go‚Äù takes you by the hand in a linear path through the magical world of the Gopher, with compiled information, just what you need to get an idea of how everything works without letting your memory overflow. At the end, it gives you a ton of links to deep dive into some subjects, like concurrency, and some more practical tutorials, like web servers and CLIs.\nYou also have Go by Example, which gives you a brief explanation and examples for common Go usage. It‚Äôs great because it has an index with the subject associated‚Äîsomething to help you remember some stuff without having to go through the tour all over again. These two are a great combo for starters. And if you want to expand more, there‚Äôs the Go Specification.\nAnd of course, you have the amazing ‚ÄúEffective Go,‚Äù a guideline to write idiomatic Golang. It‚Äôs a must-read. I know it‚Äôs long, like this blog post is becoming, but it‚Äôs worth your time.\nThe Release Notes are amazing, always summarizing the main changes in the language first, then they go tool by tool, package by package. It‚Äôs really made for humans to read, and it‚Äôs great as a guide to understand the impact on your code. You can easily look at each topic, see what can impact you, and test or change your code to use the newest modifications.\nAnd of course, we cannot forget the Standard Library Reference. It has all the packages, all the functions, methods, explanations, and examples. It‚Äôs amazing.\nFast to learn I experienced this and have heard from many others the same. Why?\nIt becomes pretty obvious after the last paragraphs I wrote about the documentation üòÑ. It really has a way to onboard you fast and let you dive into the language as you need and want.\nBut it‚Äôs not only that, there‚Äôs more‚Ä¶\nGo is simple Just looking at some data, Go is one of the mainstream languages with the fewest reserved words:\nJava: \u0026gt; 60 JavaScript: \u0026gt; 50 Rust: \u0026gt; 35 Python: \u0026gt; 30 Go: 25 How is that possible? A simple example that I like is that you don‚Äôt have while; you just use for without a condition. Do you want to make a function private? Just use lowercase.\nGo tries (almost always) to be concise, to have as few ways as possible of doing the same thing. It wants to give you tools (types, functions, methods) to allow you to build your logic, not to build everyone‚Äôs logic and package it. For example, we don‚Äôt have for and foreach like in JS. Of course, there are methods from the slices package to sort, compare, and we have iterators now. But all of them have their purpose; it‚Äôs not simply a way to avoid creating an i variable in the for loop. You could argue that in Go there is the range to do something similar to what foreach does. But it has more specific uses, like ranging over channels.\nBecause of this simplicity, Go is easy to read‚Äîeven the standard library internal code. They really do what they suggest you do. Go is humble; it doesn‚Äôt try to be unnecessarily clever and fancy, it just does the work. No classes, no inheritance, just composition.\nSimplicity has a strong relation with being explicit in this case, and sometimes it has its price: more code written, like in the case of error handling in Go. üò¨\nGo is reliable Go has the philosophy of backwards compatibility at all costs, avoiding breaking changes on major or minor versions. It happened in the past, of course‚Äîthere‚Äôs the famous loopvar change where they changed how the loop variable behaves. It was in many cases the root of bugs, but that‚Äôs because of a dissonance between the behaviour and what most people expected, and at the end, it was just behaviour. And the behaviour changed; maybe someone was relying on the way things were, and the fix actually caused a new bug. Who knows? Not me, I read the release notes every time. That‚Äôs why I always advise you to read them before updating your Go version, especially if it‚Äôs a major version.\nAlthough we don‚Äôt have an exact date of release of new Go versions, we can count on two major releases a year.\nGo improves Go is always seeking improvement in all areas: performance of the compiler, of the packages (like faster JSON encoding), and bringing new toys, like iterators and generics. I don‚Äôt know about you, but for me, all this effort to bring new features and improve things gets me excited like when a new video game console will be launched or a new Star Wars movie will be released (when they were good).\nI know much of this stuff is not new, like generics or PGO. But all of it is thought through carefully and discussed in the community before being merged. And I think Go and its community are an ecosystem that revives and brings light to some old tech in a way that people think it‚Äôs new. Because they do it in a developer-friendly way, like PGO. It was already a thing in C++ and other languages. But if you search PGO today, the majority of content, posts, and talks will be related to Golang.\nThe Community This is another great point: Golang has an active community of enthusiasts. You have official channels for it‚ÄîSlack, Google Groups‚Äîand even the Go repository is a great place to get involved in discussions inside the issues. You can point out improvements or bugs and collaborate through pull requests.\nThere are tons of Golang groups and conferences, and I see more and more starting. Here in Brazil, we have meetups like Golang SP, Floripa Gophers, and many GDGs around the country talk about Golang. Of course, there are the main conferences all over the globe, like Gophercon Latam, Golab, Gophercon US, Gophercon UK, etc. And many other conferences have some space for Golang talks, especially DevOps ones, like DevOps Days and Container Days. And there‚Äôs space for beginners and experts; every conference I attended, people are nice and open to help someone that‚Äôs struggling to start with the language.\nLet‚Äôs not forget the newsletters. We have the Golang Weekly and, for the Portuguese speakers, thanks to Elton Minetto, there is A Semana Go. This way, you can always keep up to date with news about the language and interesting projects.\nI know not everyone wants to think about programming after work, but if you want and enjoy it, there are so many resources and people that share the same feeling and excitement about Go.\nAsynchronous made easy Go has eliminated the distinction between synchronous and asynchronous code.\nBob Nystrom\nThis statement is strong and impactful. I really recommend this post.\nGolang is amazing because it is built with goroutines, even the main one. Each goroutine is a user-level thread managed by the Go runtime, using a pool of OS threads. The way it works enables avoiding all the async-await hell. Any function can become asynchronous with the keyword go; you don‚Äôt have a chain of changes over the functions that are calling it.\nWe also have the usage of channels, the select statement, mutexes, waitgroups, errgroups‚Äîlots of features to help you work with concurrency. Switching from JS to Go, it was a breath of fresh air and one of the main things that\u0026hellip;\nPerformance You probably were waiting for me to come to this topic; everyone talks about that. But for me, and maybe for most developers, it should be the least important. This is not why I use Go. Every company I worked for, every system I built, could have been built with other languages (even JS ü§¢). Most of us don‚Äôt count microseconds of performance.\nAnd we have lots of benchmarks all over the internet stating that language X is better than language Y. And most of these benchmarks have shady methodology and lots of biases. A benchmark is a scientific research; it must have a well-defined plan and consider its limitations. There are numerous situations to test, numerous structures and algorithms that these tests will never touch. There are compilation and interpretation improvements that can happen if you run the same code more than once. Maybe a language has a faster encoding of JSON, but another is faster for decoding because of the implementation in each one. And usually, the person comparing tech A to tech B is an expert with A and has a basic understanding of B; of course, it‚Äôs easier for them to extract more performance from A.\nBut yeah, Go is fast, and you can build your web server; it will handle your load. You probably don‚Äôt need Rust or Zig for it. Remember that the language is just part of your latency; usually, we have lots of components on the way‚Äîcontainer clusters, lots of network hops, load balancers, API gateways, etc.\nSummary Of course, there are things I don‚Äôt like in Go, like the built-in make, more specifically its signature func make(t Type, size ...IntegerType) Type. It‚Äôs not clear what the possible parameters are, and for different data structures, the behaviour is different. I always get confused when using it. I will not dive into the problems; that‚Äôs not the point now (maybe in another post).\nAt the end, the main things that make me love Golang are its ease of use, simplicity, and community. I don‚Äôt have a problem changing programming languages at work, but if I had to choose, I would prefer to stick with it, at least for now. We see more and more Golang jobs opening each year and more devs starting their journey learning Go. Remember, Go is a general-purpose language. We usually see APIs and CLIs being built with Go, but it‚Äôs possible to serve SPAs, run WebAssembly code generated from Go, and deal with AI stuff. Go is still v1. The future ahead is bright and exciting.\n","permalink":"https://blog.o-mago.com/posts/should-i-stay-or-should-i-go/","summary":"\u003cp\u003eLet\u0026rsquo;s talk about why Go is so interesting and why I love it!\u003c/p\u003e\n\u003cp\u003eIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\u003c/p\u003e","title":"Should I Stay or Should I Go?"},{"content":"","permalink":"https://blog.o-mago.com/posts/","summary":"posts","title":"Posts"}]