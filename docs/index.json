[{"content":"Today I‚Äôll talk a little bit about frontend (don‚Äôt be mad ü•∫üôè). First, I‚Äôll briefly introduce what WebAssembly is, and then how it relates to Go. I‚Äôll probably write more about this subject, but first I want to make this introduction to get everyone on the same page. The idea of this blog is not to post gigantic articles, but smaller ones every week (I‚Äôll try my best üòâ) that can talk to each other.\nI presented on this subject at GopherCon Latam 2024. If you prefer video and understand Portuguese, here is a link.\nThe history Grab your popcorn, it‚Äôs history time!\nBefore WebAssembly was born, a wild battle was raging on the internet. The year was 2010, and Google and Mozilla were deciding what the future of the web would look like.\nIn 2008, Google created the Native Client (NaCl), a way to run a subset of native machine code (x86 for instance) in a sandbox in your browser. The code ran at great speed, but it couldn‚Äôt access the existing Web API because everything was running in a separate process, so you had to deal with a plugin API, like Flash used to do.\nMozilla started a new project called Emscripten in 2011, a compiler from C and C++ (or any LLVM-supported language) into JavaScript (at that time). It‚Äôs web-friendly because, at the end of the day, it‚Äôs JS and can communicate with the Web API. But it‚Äôs bad for the same reason, because it‚Äôs JS ü§™, so it‚Äôs slow. Then they decided to create asm.js, a subset of JS with the capabilities of some AOT (Ahead of Time) compilation, more reliable and consistent optimizations than the JIT (just in time) compilation. This enabled asm.js to run faster than normal JS code, but it was still JavaScript, so it couldn‚Äôt compete with binary code.\nIn 2013, Google and Mozilla put their differences aside and started working together, collaborating, and in 2015 NaCl and asm.js had a baby called WebAssembly:\nIt can interact with the DOM and Web API It‚Äôs not JavaScript; it‚Äôs binary code that runs in a VM (to be portable) If you want to know more about this story in detail, take a look at this presentation by Alon Zakai, the creator of Emscripten and co-creator of WebAssembly.\nWebAssembly When we break the term into Web and Assembly, we might think it is a way to run Assembly on the Web, in your browser, right? That‚Äôs (almost) right; it‚Äôs actually a low-level assembly-like code.\nWebAssembly (abbreviated¬†Wasm) is a binary instruction format for a stack-based virtual machine.\nThis is quite enlightening. Now we know that WebAssembly is a programming language (a low-level one), so it means you can write it, but it‚Äôs not meant to be written by you (usually). It was made to be compiled from other languages like Go, Rust, C, etc.\nAnd the idea here is not for WebAssembly to kill JavaScript (I wish üòÖ), it‚Äôs for them to work together, to be complementary. You can take advantage of JS flexibility to work with your webpage‚Äôs common usability, simple components, texts, inputs, etc., and leave the hard work to your WASM code when you need to deal with complex algorithms, CPU or GPU-heavy processes.\nWebAssembly is especially useful for porting games to your browser; Unity uses it to export games for the web. Tools like Figma took advantage of WASM, writing their code in C++ and running close to native speed in the browser.\nBut it doesn‚Äôt stop there; WASM is being used for much more. Although it was conceived with browsers in mind, at the end of the day it runs on a VM‚Äîthe browser just happens to have a runtime that runs it, like V8 on Chrome.\nThat‚Äôs when WASI (WebAssembly System Interface) comes into play in 2019, a standardization of APIs for WebAssembly to deal with systems outside the browser, like network stuff and filesystems. In a nutshell, you can run your CLIs and backend services as WASM binaries. To do this, you need a runtime, and there are lots of options like wazero and wasmtime.\nYou can even have one of these runtimes inside your Kubernetes cluster and, instead of using containers, you can run WebAssembly binaries or run WASM files inside your containers. There‚Äôs a CNCF project called wasmcloud that can orchestrate your WASM services. It‚Äôs still uncertain what the future holds; some say WASM will replace containers as we know them because they‚Äôre fast to start, smaller than container images, and secure because they run isolated from the host in their own sandbox. But at the same time, WASM code is limited to the functionalities standardized by WASI, and not all languages have compilers to WASM.\nAnother use case that I really like is tools where you need SDKs for different languages. You can create the core functionalities in Rust, for example, and compile to WASM. Then, instead of recreating the whole SDK in different languages, you just create the ‚Äúinterfaces‚Äù for that specific language that call all the WASM logic from that binary you compiled. Hence the title of the post, it\u0026rsquo;s a \u0026lsquo;Tower of Babel\u0026rsquo;, a common way for the programming languages to communicate. A good example is some of the Flipt‚Äôs SDKs like Go, JavaScript, and React. They have a pretty interesting article about this choice.\nGo + WebAssembly I hope you now know at least a little bit about what WebAssembly is and what it‚Äôs capable of. Now let‚Äôs talk about Go‚Äôs support for WebAssembly.\nIt was introduced experimentally in 2018 with Go 1.11, meaning it got a WASM compiler. This port evolved, and in 2023 WASI support was introduced experimentally in Go 1.21. And if you pay attention to the release notes, it‚Äôs common for some new Go versions to have a WebAssembly section with some improvements, like binary size.\nTalking about the binary size of WASM, usually Golang ones are bigger and slower than Rust WASM binaries, for instance. This is due to having to include all the goroutine runtime, garbage collector, maps, and other Golang stuff into it. Like I said, it has improved a lot. Another thing that could help reduce size and improve performance would be targeting WASM runtimes with garbage collector extension. Since 2023, Chrome already supports WASM GC by default. This way, the Go compiler wouldn‚Äôt need to include the GC in the binary, so it would be smaller‚Ä¶\nBut we have an option for smaller WASM binaries using Golang; it‚Äôs called TinyGo, an embedded systems and WebAssembly-focused compiler based on LLVM, implementing lots of optimizations, removing some Go runtime capabilities, not supporting some Go standard libraries, and using a different minimal garbage collector.\nWhat should you use for WASM? It‚Äôs up to you and your project. If you want to port already written standard Go code to WASM, maybe it will be better to just compile it using the Go tool. If it‚Äôs a new app, simpler and that must be as small as possible, TinyGo is the way. If you have the chance, test both and compare them; performance may vary depending on the tasks you are dealing with.\nHands on For these examples, I‚Äôm using Go 1.24.5 and TinyGo 0.38.0:\nLet‚Äôs do a simple example just to help you understand things a little bit more. I‚Äôll create a simple Go code just to print ‚ÄúWebAssembly‚Äù in a main.go file. The idea here is for our browser to print this message at the end:\npackage main func main() { println(\u0026#34;WebAssembly\u0026#34;) } The Go tool already has the built-in capability of compiling to WASM. In order to compile it to run in our browser, we need two steps. I‚Äôve created an assets folder that will contain all our files to be served by our file server. First, build our binary:\nGOOS=js GOARCH=wasm go build -o ./assets/main.wasm Second, we need a supporting file (it‚Äôs already on our machine as soon as we install Go) that allows us to communicate with our JavaScript code, so:\ncp \u0026#34;$(go env GOROOT)/libs/wasm/wasm_exec.js\u0026#34; ./assets Then we create an html file that will import both files with the following content:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;main.wasm\u0026#34;), go.importObject).then((result) =\u0026gt; { go.run(result.instance); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Lastly, I will create a simple Go file server pointing to our assets folder:\npackage main import ( \u0026#34;net/http\u0026#34; ) func main() { http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;./assets\u0026#34;))) } And as expected, the console printed our message:\nCongratulations, you have just run your first Go code in the browser (if you have never used WebAssembly with Go before, of course üòÑ).\nI‚Äôve talked about TinyGo, so let‚Äôs compile our WASM file with it. The main.go will not change, nor will our server or HTML. The only difference here is the build commands:\nGOOS=js GOARCH=wasm tinygo build -o ./assets/main.wasm And the JS support file is located in a different place:\ncp \u0026#34;/usr/local/lib/tinygo/targets/wasm_exec.js\u0026#34; ./assets/wasm_exec.js The result is the same, but the file size is quite different. Renaming them to go.wasm and tiny-go.wasm:\nWe can see that the TinyGo one is only 95K and the Go one is 1.5MB, which means 15 times bigger üò±. This is not a good example to dive into performance (maybe in another post), but choose wisely üßô‚Äç‚ôÇÔ∏è\nReal world example Ok, this is interesting, but it‚Äôs just ‚ÄúHello World‚Äù code‚Äînot so exciting, right? Remember I talked about how WebAssembly is interesting for porting games to the web? Well‚Ä¶\nAt GopherCon 2024, where I presented a WebAssembly talk, there was another speaker from Varginha, a Brazilian city known for the most notorious alien appearance in Brazil, Matheus Mina (‚Äúseus cabelo √© da hora‚Äù, as Mamonas Assassinas would say üòÇ). We were talking in the VIP room, and he was developing a game using Ebitengine. It‚Äôs that game where you have to order the numbers by sliding the pieces. We talked, and I decided to port his game to the web, so I forked it, added touch screen support, compiled it to WASM, and uploaded it to my website using Github Pages.\nHere‚Äôs the code and the game can be played at this address.\nWhat about you? Did you know about WebAssembly? Have you worked with it before? What are your thoughts on the future of WASM and its integration with Go?\n","permalink":"https://blog.o-mago.com/posts/webassembly-the-tower-of-babel-of-programming/","summary":"\u003cp\u003eToday I‚Äôll talk a little bit about frontend (don‚Äôt be mad ü•∫üôè). First, I‚Äôll briefly introduce what WebAssembly is, and then how it relates to Go. I‚Äôll probably write more about this subject, but first I want to make this introduction to get everyone on the same page. The idea of this blog is not to post gigantic articles, but smaller ones every week (I‚Äôll try my best üòâ) that can talk to each other.\u003c/p\u003e","title":"WebAssembly: The Tower of Babel of programming, a Go approach"},{"content":"Have you ever got confused about testing functions using time.Now()? What about functions calling goroutines?\nWell your problems are over‚Ä¶ or they will be over with Go 1.25, that will be released soon (probably next month) featuring the new testing/synctest package\nWhat does synctest do? Basically, it allows you to run your tests in a ‚Äúbubble‚Äù, a kind of isolation from the rest of the test.\nIt‚Äôs meant to make your life easier when testing concurrent code, avoiding flaky tests, changing your production code to be testable, and reducing the time to run tests.\nThis bubble has two main features:\nA fake clock A blocking mechanism for goroutines It has two exported functions (actually three, but one is already deprecated üò≤; we‚Äôll discuss this more in a bit):\nfunc Test(t *testing.T, f func(*testing.T)) func Wait() Test creates what we call a ‚Äúbubble.‚Äù It‚Äôs the function that allows you to stop the clock in the past and control its flow as if you were the Flash running so fast ‚ö°. It waits until all goroutines have returned and will also make the test fail if any goroutine becomes deadlocked. It‚Äôs a way to even detect goroutine leaks.\nWait will wait until all goroutines get into a state called ‚Äúdurably blocked.‚Äù This means waiting until they have already finished or are blocked and won‚Äôt keep running unless an event is triggered by another goroutine inside the bubble to unblock them. I know it‚Äôs a bit confusing, but we‚Äôll see an example soon.\nThe fake clock The time.Now() will return midnight UTC 2000-01-01, meticulously chosen to remind us about the fears of the year 2000 problem, or millennium bug ü§™. And time won‚Äôt advance until all goroutines inside the bubble are blocked, for example, by using a time.Sleep to block them. It‚Äôs so much easier to control time this way, instead of having to rely on random sleep times and creating flaky tests.\nI used to do things like this:\nvar _now = time.Now func TimeToSendMessage(fallbackTime time.Time) time.Time { now := _now() if now.Hour() \u0026gt; 9 \u0026amp;\u0026amp; now.Hour() \u0026lt; 18 { return now } return fallbackTime } This code basically returns the time to send a message (SMS or something like this). We don‚Äôt want to bother our clients by sending messages outside business hours, so we check the hour of our current day. If we are before 9 a.m. or after 6 p.m., the system schedules a message for a fallback time.\nFocus on the _now variable. I created it to hold the function time.Now, because this way I would be able to ‚Äúmock‚Äù the time.Now like this:\nfunc TestTimeToSendMessage(t *testing.T) { inputTime := time.Date(2025, 10, 8, 12, 0, 0, 0, time.UTC) tt := []struct { name string mockedNow time.Time expected time.Time }{ { name: \u0026#34;should return now\u0026#34;, mockedNow: time.Date(2025, 5, 8, 12, 0, 0, 0, time.UTC), expected: time.Date(2025, 5, 8, 12, 0, 0, 0, time.UTC), }, { name: \u0026#34;should return fallback time\u0026#34;, mockedNow: time.Date(2025, 5, 8, 20, 0, 0, 0, time.UTC), expected: inputTime, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { _now = func() time.Time { return tc.mockedNow } result := TimeToSendMessage(inputTime) if result != tc.expected { t.Fatalf(\u0026#34;wrong output\u0026#34;) } }) } } I always felt dirty doing things this way. We have some problems here:\nWe can‚Äôt run these test cases in parallel; we would have a data race since we are reassigning the value of _now, and our tests would be flaky. I had to add more code, complexity, and ugliness to the production code in order to test it. Now my problems are over; I can just do the following:\nfunc TimeToSendMessage(fallbackTime time.Time) time.Time { now := time.Now() if now.Hour() \u0026gt; 9 \u0026amp;\u0026amp; now.Hour() \u0026lt; 18 { return now } return fallbackTime } func TestTimeToSendMessage(t *testing.T) { inputTime := time.Date(2025, 10, 8, 12, 0, 0, 0, time.UTC) tt := []struct { name string sleepDuration time.Duration expected time.Time }{ { name: \u0026#34;should return now\u0026#34;, sleepDuration: 12 * time.Hour, expected: time.Date(2000, 1, 1, 12, 0, 0, 0, time.UTC), }, { name: \u0026#34;should return fallback time\u0026#34;, sleepDuration: 0, expected: inputTime, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Run(func() { time.Sleep(tc.sleepDuration) // time.Now() will add this sleep time result := TimeToSendMessage(inputTime) if !result.Equal(tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) }) } } This way, I don‚Äôt have to change production code, and I can run the tests in parallel without worries.\nIf you don‚Äôt believe me, here‚Äôs the code.\nBlocking mechanism for goroutines I‚Äôve already explained the Wait function; let‚Äôs go to an example.\nImagine a function DoSomething that basically receives a string and returns a string pointer. The pointer will default to the initialString address (and value). But we have a goroutine inside that will change the value of the pointer to \u0026quot;test\u0026quot; if the initialString has the value \u0026quot;returnTest\u0026quot;.\nHere‚Äôs the code and the test:\nfunc DoSomething(initialString string) *string { strPointer := \u0026amp;initialString go func() { if initialString != \u0026#34;returnTest\u0026#34; { return } *strPointer = \u0026#34;test\u0026#34; }() return strPointer } func TestDoSomething(t *testing.T) { tt := []struct { name string input string expected string }{ { name: \u0026#34;should return \u0026#39;any\u0026#39; pointer\u0026#34;, input: \u0026#34;any\u0026#34;, expected: \u0026#34;any\u0026#34;, }, { name: \u0026#34;should return \u0026#39;test\u0026#39; pointer\u0026#34;, input: \u0026#34;returnTest\u0026#34;, expected: \u0026#34;test\u0026#34;, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { result := DoSomething(tc.input) if *result != tc.expected { t.Fatalf(\u0026#34;wrong result %s\u0026#34;, *result) } }) }) } } First, we don‚Äôt have a synctest.Wait() call, as you can see, and the output of our code is the following:\n=== RUN TestDoSomething === RUN TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === RUN TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer prog_test.go:50: wrong result returnTest --- FAIL: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer (0.00s) --- FAIL: TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer (0.00s) FAIL It failed. That‚Äôs because we are not waiting for all the goroutines to become ‚Äúdurably blocked.‚Äù Changing our test:\nfunc TestDoSomething(t *testing.T) { tt := []struct { name string input string expected string }{ { name: \u0026#34;should return \u0026#39;any\u0026#39; pointer\u0026#34;, input: \u0026#34;any\u0026#34;, expected: \u0026#34;any\u0026#34;, }, { name: \u0026#34;should return \u0026#39;test\u0026#39; pointer\u0026#34;, input: \u0026#34;returnTest\u0026#34;, expected: \u0026#34;test\u0026#34;, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { result := DoSomething(tc.input) synctest.Wait() if *result != tc.expected { t.Fatalf(\u0026#34;wrong result %s\u0026#34;, *result) } }) }) } } The new output will be:\n=== RUN TestDoSomething === RUN TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === RUN TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer --- PASS: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer (0.00s) PASS Goroutine Leaks I will not dive too much into this subject‚Äîmaybe it deserves a proper post. But the synctest package can be used to detect goroutine leaks. Goroutine what???\nIt‚Äôs similar to the idea of memory leaks‚Äîa goroutine that‚Äôs stuck and should have already ended.\nIt can happen for different reasons, but one of them is unbuffered channels and early returns.\nvar ( ErrorProcess = errors.New(\u0026#34;process error\u0026#34;) ErrorRequest = errors.New(\u0026#34;request error\u0026#34;) ) func DoSomething(input string) error { c := make(chan error) go func() { c \u0026lt;- process() }() if err := request(input); err != nil { return err } err := \u0026lt;-c return err } func process() error { time.Sleep(2 * time.Second) return ErrorProcess } func request(input string) error { time.Sleep(1 * time.Second) if input == \u0026#34;error\u0026#34; { return ErrorRequest } return nil } Let‚Äôs give an example. Imagine a function where you have an error channel and you process some stuff on a goroutine; if any error happens, you produce an error in the channel. Then you do some request, and after, you consume the error from the channel in order to return it. But if this request in the middle fails, it will return, and the consumer will vanish faster than beer near me. As we already know (or maybe you are learning here üòÑ), unbuffered channels must have active producers and consumers at the same time (we don\u0026rsquo;t have a buffer to hold the information). In this case, we have lost the consumer, so the producer will stall and block our goroutine. There‚Äôs your leak.\nWhen we try to test it without synctest, we get:\nfunc TestDoSomethingNoSynctest(t *testing.T) { tt := []struct { name string input string expected error }{ { name: \u0026#34;should return process error\u0026#34;, input: \u0026#34;ok\u0026#34;, expected: ErrorProcess, }, { name: \u0026#34;should return request error\u0026#34;, input: \u0026#34;error\u0026#34;, expected: ErrorRequest, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() err := DoSomething(tc.input) if !errors.Is(err, tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) } } === RUN TestDoSomethingNoSynctest === RUN TestDoSomethingNoSynctest/should_return_process_error === PAUSE TestDoSomethingNoSynctest/should_return_process_error === RUN TestDoSomethingNoSynctest/should_return_request_error === PAUSE TestDoSomethingNoSynctest/should_return_request_error === CONT TestDoSomethingNoSynctest/should_return_process_error === CONT TestDoSomethingNoSynctest/should_return_request_error --- PASS: TestDoSomethingNoSynctest (0.00s) --- PASS: TestDoSomethingNoSynctest/should_return_request_error (1.00s) --- PASS: TestDoSomethingNoSynctest/should_return_process_error (2.00s) PASS Oh! Beautiful, my code works, it‚Äôs perfect‚Ä¶ ewwww, not actually‚Ä¶ Running my test with synctest:\nfunc TestDoSomething(t *testing.T) { tt := []struct { name string input string expected error }{ { name: \u0026#34;should return process error\u0026#34;, input: \u0026#34;ok\u0026#34;, expected: ErrorProcess, }, { name: \u0026#34;should return request error\u0026#34;, input: \u0026#34;error\u0026#34;, expected: ErrorRequest, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { err := DoSomething(tc.input) if !errors.Is(err, tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) }) } } === RUN TestDoSomething === RUN TestDoSomething/should_return_process_error === PAUSE TestDoSomething/should_return_process_error === RUN TestDoSomething/should_return_request_error === PAUSE TestDoSomething/should_return_request_error === CONT TestDoSomething/should_return_process_error === CONT TestDoSomething/should_return_request_error --- FAIL: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_process_error (0.00s) --- FAIL: TestDoSomething/should_return_request_error (0.00s) panic: deadlock: main bubble goroutine has exited but blocked goroutines remain [recovered, repanicked] goroutine 18 [running]: testing.tRunner.func1.2({0x567da0, 0xc000212000}) /usr/local/go-faketime/src/testing/testing.go:1872 +0x237 testing.tRunner.func1() /usr/local/go-faketime/src/testing/testing.go:1875 +0x35b panic({0x567da0?, 0xc000212000?}) /usr/local/go-faketime/src/runtime/panic.go:783 +0x132 internal/synctest.Run(0xc00018e000) /usr/local/go-faketime/src/runtime/synctest.go:251 +0x2de testing/synctest.Test(0xc000118380, 0xc00018c000) /usr/local/go-faketime/src/testing/synctest/synctest.go:282 +0x90 play.TestDoSomething.func1(0xc000118380) /tmp/sandbox4287699162/prog_test.go:67 +0x94 testing.tRunner(0xc000118380, 0xc000104040) /usr/local/go-faketime/src/testing/testing.go:1934 +0xea created by testing.(*T).Run in goroutine 7 /usr/local/go-faketime/src/testing/testing.go:1997 +0x465 goroutine 35 [sleep (durable), synctest bubble 2]: time.Sleep(0x77359400?) /usr/local/go-faketime/src/runtime/time.go:361 +0x12c play.process(...) /tmp/sandbox4287699162/prog_test.go:31 play.DoSomething.func1() /tmp/sandbox4287699162/prog_test.go:20 +0x25 created by play.DoSomething in goroutine 34 /tmp/sandbox4287699162/prog_test.go:19 +0x6b Program exited. This happens because we still have a blocked goroutine at the end of the synctest bubble. The output is a little bit confusing, I know, but there‚Äôs another alternative for it: the goleak package by Uber.\nAnd to fix this leak in our code it\u0026rsquo;s easy, we just have to transform our unbuffered channel into a buffered channel, so we can have a buffer to hold the information if the consumer is not there:\nfunc DoSomething(input string) error { c := make(chan error, 1) // Buffered channel with a capacity of 1 go func() { c \u0026lt;- process() }() if err := request(input); err != nil { return err } err := \u0026lt;-c return err } The 3rd function I said that there were actually three exported functions inside this package (at least at the time of this post). That‚Äôs because this package was first introduced as an experimental package with Go 1.24. This way, you can already preview this new change now‚Äîif your code is not stuck in an older Go version üëÄ.\nThe examples I gave used the new Go 1.25 API. It‚Äôs possible to test it easily by downloading the release candidates or using the Go Playground and selecting the Go dev branch version in the dropdown. Be aware with every experimental feature because the API can change. Quoting the release notes:\nThe package API is subject to change in future releases\nGo 1.24 release notes\nLet‚Äôs first take a look at the differences between them:\nGo 1.24:\nfunc Run(f func())\nfunc Wait()\nGo 1.25:\nfunc Run(f func())\nfunc Test(t *testing.T, f func(*testing.T))\nfunc Wait()\nAs we can see, the Wait and Run functions haven‚Äôt changed. The only change is the addition of Test. But it was actually made to replace Run. In the docs, you can read:\nfunc Run(f func()) Run is deprecated. Deprecated: Use Test instead. Run will be removed in Go 1.26. Their core functionality is the same, as we can see in the source code. They both call synctest.Run:\nfunc Run(f func()) { synctest.Run(f) } func Test(t *testing.T, f func(*testing.T)) { var ok bool synctest.Run(func() { ok = testingSynctestTest(t, f) }) if !ok { // Fail the test outside the bubble, // so test durations get set using real time. t.FailNow() } } But the change was not only the name‚Äîthe parameters are different, and Test calls testingSynctestTest, which is important. Let‚Äôs understand a little bit more about what happened here.\nThey added the t *testing.T parameter, and testingSynctestTest will basically create a new t2 *testing.T based on t. But why?\nSo T.Cleanup calls can run inside the bubble at the end of the synctest.Test function, and T.Context can return a cancellable context with a Done channel in the bubble.\nYou can see more examples about synctest in the Go blog‚Äîit was based on the experimental Go 1.24 version, but it‚Äôs pretty similar to what you can do with Go 1.25 using Test instead of Run. You can also check the package reference.\nAnd that‚Äôs all folks, thanks for your attention, hope you enjoyed ü§ò\nAnd what about you? Are you using synctest already?\n","permalink":"https://blog.o-mago.com/posts/concurrent-code-testing-with-synctest-bubbles-in-go/","summary":"\u003cp\u003eHave you ever got confused about testing functions using \u003ccode\u003etime.Now()\u003c/code\u003e? What about functions calling goroutines?\u003c/p\u003e\n\u003cp\u003eWell your problems are over‚Ä¶ or they will be over with Go 1.25, that will be released soon (probably next month) featuring the new \u003ccode\u003etesting/synctest\u003c/code\u003e package\u003c/p\u003e\n\u003ch3 id=\"what-does-synctest-do\"\u003eWhat does synctest do?\u003c/h3\u003e\n\u003cp\u003eBasically, it allows you to run your tests in a ‚Äúbubble‚Äù, a kind of isolation from the rest of the test.\u003c/p\u003e\n\u003cp\u003eIt‚Äôs meant to make your life easier when testing concurrent code, avoiding flaky tests, changing your production code to be testable, and reducing the time to run tests.\u003c/p\u003e","title":"Concurrent code testing with synctest bubbles in Go"},{"content":"Let\u0026rsquo;s talk about why Go is so interesting and why I love it!\nIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\n‚ÄúGo‚Äù by Pearl Jam, ‚ÄúGo‚Äù by Blink-182, ‚ÄúGo‚Äù by Indigo Girls, ‚ÄúGo‚Äù by Kelly Clarkson, \u0026ldquo;Go\u0026rdquo; by The Smashing Pumpkins, \u0026ldquo;Go\u0026rdquo; by Def Leppard, \u0026ldquo;Go Go Go\u0026rdquo; by Chuck Berry, ‚ÄúHere I Go Again‚Äù by Whitesnake, ‚ÄúGo All the Way‚Äù by Raspberries, ‚ÄúGo Your Own Way‚Äù by Fleetwood Mac ‚Ä¶ and the list goes on!\nAfter some consideration, I found out I had lost lots of time searching and listening to songs, and I decided to go ü§≠ with The Clash.\nBut it fits perfectly with the theme. I‚Äôm also a mentor at ADPList, and many of my mentees ask me this question from the title. Ok, not exactly like that, but like ‚ÄúShould I learn Go?‚Äù or ‚ÄúWhy do you like Go?‚Äù\nThe first question is hard to answer, but as a senior engineer, I have the answer: ‚ÄúIt depends.‚Äù Usually, I start asking, not answering, because it depends on each one\u0026rsquo;s reality. I will not dive into this question today (maybe in another post). Today I want to talk about the second one; maybe it helps you reflect on the first one and clear things up for you, maybe not.\nFirst I want to tell my story quickly: how I ended up working with Go, when it started and why I chose to keep going.\nHow it started My first contact with Golang was on a cold night (not that cold, this is Brazil) in September 2020. I was working with JavaScript at that time, I was unhappy (of course, it‚Äôs JS ü§™) and wanted to change jobs. A friend of mine was working in a company using Go and said they were looking for engineers, and wanted to refer me. I didn‚Äôt know Go at the time (just by name), but he said the language was great. I was unsure, but I accepted it and started the selection process.\nThe first step was a LeetCode-like challenge, but it wasn‚Äôt mandatory to use Go. But I wanted to show ‚ÄúI‚Äôm a fast learner,‚Äù so I took one day to study the documentation and did some basic LeetCode with it. I took the test the next day and passed. At that point, I knew I wasn‚Äôt that fast; actually, the language is ‚Äúfast learnable.‚Äù\nThese were the first characteristics of the language that I noticed:\n‚ÄúIt is fast to learn‚Äù ‚ÄúIt has amazing and intuitive documentation‚Äù At that point, I was convinced to give it a try if I got the job.\nI got the job, and then the more I dived into the language, tools, and the community, the more I fell in love with it. ‚ù§Ô∏è\nSo let‚Äôs break into these and other reasons why I fell in love.\nGreat Documentation Why is the documentation great?\nIt‚Äôs meant for learners. When you enter the Go documentation webpage, you don‚Äôt see lots of texts and references, etc. You see lots of links to resources for learning, tutorials, examples, good practices, guidelines, and explanations of the internals. It has resources for starters and for those who want to dive into the internals of Go, like how the garbage collector works. They make it easy for you to start using, but they want you to understand how Go works‚Äîreally understand what you are doing.\nOne of the main parts is the Learn Go section. It‚Äôs so amazing; it‚Äôs where I first learned Go, and that‚Äôs my suggestion to all my mentees and everyone that asks. I‚Äôm not a video tutorial fan, so I tend to prefer written material.\nIt tells you everything very straightforwardly, starting with how to install. Then you have the amazing Tour of Go, where it will teach you all the basics with split sections and interactive examples for you to run using the Go Playground. It‚Äôs great because many people get afraid when they see lots of texts, without a certain order‚Äîthey freeze. The ‚ÄúTour of Go‚Äù takes you by the hand in a linear path through the magical world of the Gopher, with compiled information, just what you need to get an idea of how everything works without letting your memory overflow. At the end, it gives you a ton of links to deep dive into some subjects, like concurrency, and some more practical tutorials, like web servers and CLIs.\nYou also have Go by Example, which gives you a brief explanation and examples for common Go usage. It‚Äôs great because it has an index with the subject associated‚Äîsomething to help you remember some stuff without having to go through the tour all over again. These two are a great combo for starters. And if you want to expand more, there‚Äôs the Go Specification.\nAnd of course, you have the amazing ‚ÄúEffective Go,‚Äù a guideline to write idiomatic Golang. It‚Äôs a must-read. I know it‚Äôs long, like this blog post is becoming, but it‚Äôs worth your time.\nThe Release Notes are amazing, always summarizing the main changes in the language first, then they go tool by tool, package by package. It‚Äôs really made for humans to read, and it‚Äôs great as a guide to understand the impact on your code. You can easily look at each topic, see what can impact you, and test or change your code to use the newest modifications.\nAnd of course, we cannot forget the Standard Library Reference. It has all the packages, all the functions, methods, explanations, and examples. It‚Äôs amazing.\nFast to learn I experienced this and have heard from many others the same. Why?\nIt becomes pretty obvious after the last paragraphs I wrote about the documentation üòÑ. It really has a way to onboard you fast and let you dive into the language as you need and want.\nBut it‚Äôs not only that, there‚Äôs more‚Ä¶\nGo is simple Just looking at some data, Go is one of the mainstream languages with the fewest reserved words:\nJava: \u0026gt; 60 JavaScript: \u0026gt; 50 Rust: \u0026gt; 35 Python: \u0026gt; 30 Go: 25 How is that possible? A simple example that I like is that you don‚Äôt have while; you just use for without a condition. Do you want to make a function private? Just use lowercase.\nGo tries (almost always) to be concise, to have as few ways as possible of doing the same thing. It wants to give you tools (types, functions, methods) to allow you to build your logic, not to build everyone‚Äôs logic and package it. For example, we don‚Äôt have for and foreach like in JS. Of course, there are methods from the slices package to sort, compare, and we have iterators now. But all of them have their purpose; it‚Äôs not simply a way to avoid creating an i variable in the for loop. You could argue that in Go there is the range to do something similar to what foreach does. But it has more specific uses, like ranging over channels.\nBecause of this simplicity, Go is easy to read‚Äîeven the standard library internal code. They really do what they suggest you do. Go is humble; it doesn‚Äôt try to be unnecessarily clever and fancy, it just does the work. No classes, no inheritance, just composition.\nSimplicity has a strong relation with being explicit in this case, and sometimes it has its price: more code written, like in the case of error handling in Go. üò¨\nGo is reliable Go has the philosophy of backwards compatibility at all costs, avoiding breaking changes on major or minor versions. It happened in the past, of course‚Äîthere‚Äôs the famous loopvar change where they changed how the loop variable behaves. It was in many cases the root of bugs, but that‚Äôs because of a dissonance between the behaviour and what most people expected, and at the end, it was just behaviour. And the behaviour changed; maybe someone was relying on the way things were, and the fix actually caused a new bug. Who knows? Not me, I read the release notes every time. That‚Äôs why I always advise you to read them before updating your Go version, especially if it‚Äôs a major version.\nAlthough we don‚Äôt have an exact date of release of new Go versions, we can count on two major releases a year.\nGo improves Go is always seeking improvement in all areas: performance of the compiler, of the packages (like faster JSON encoding), and bringing new toys, like iterators and generics. I don‚Äôt know about you, but for me, all this effort to bring new features and improve things gets me excited like when a new video game console will be launched or a new Star Wars movie will be released (when they were good).\nI know much of this stuff is not new, like generics or PGO. But all of it is thought through carefully and discussed in the community before being merged. And I think Go and its community are an ecosystem that revives and brings light to some old tech in a way that people think it‚Äôs new. Because they do it in a developer-friendly way, like PGO. It was already a thing in C++ and other languages. But if you search PGO today, the majority of content, posts, and talks will be related to Golang.\nGo is an ecosystem Golang is more than a language; it is a Swiss Army knife. When you install it from the official website, you get a powerful tool with the capabilities of:\ntesting (test) building (build) formatting and fixing mistakes (fmt, vet) managing modules (mod) managing dependencies (get) analyzing profiles (tool pprof) And benchmarking, outputting test coverage, and much more‚Ä¶\nIt‚Äôs all accessible out of the box with the command line go \u0026lt;command\u0026gt;. You don‚Äôt have to install different tools to start coding and maintaining your code. Of course, there are some third-party tools that can help you along the way, like golangci-lint.\nThe Community This is another great point: Golang has an active community of enthusiasts. You have official channels for it‚ÄîSlack, Google Groups‚Äîand even the Go repository is a great place to get involved in discussions inside the issues. You can point out improvements or bugs and collaborate through pull requests.\nThere are tons of Golang groups and conferences, and I see more and more starting. Here in Brazil, we have meetups like Golang SP, Floripa Gophers, and many GDGs around the country talk about Golang. Of course, there are the main conferences all over the globe, like Gophercon Latam, Golab, Gophercon US, Gophercon UK, etc. And many other conferences have some space for Golang talks, especially DevOps ones, like DevOps Days and Container Days. And there‚Äôs space for beginners and experts; every conference I attended, people are nice and open to help someone that‚Äôs struggling to start with the language.\nLet‚Äôs not forget the newsletters. We have the Golang Weekly and, for the Portuguese speakers, thanks to Elton Minetto, there is A Semana Go. This way, you can always keep up to date with news about the language and interesting projects.\nI know not everyone wants to think about programming after work, but if you want and enjoy it, there are so many resources and people that share the same feeling and excitement about Go.\nAsynchronous made easy Go has eliminated the distinction between synchronous and asynchronous code.\nBob Nystrom\nThis statement is strong and impactful. I really recommend this post.\nGolang is amazing because it is built with goroutines, even the main one. Each goroutine is a user-level thread managed by the Go runtime, using a pool of OS threads. The way it works enables avoiding all the async-await hell. Any function can become asynchronous with the keyword go; you don‚Äôt have a chain of changes over the functions that are calling it.\nWe also have the usage of channels, the select statement, mutexes, waitgroups, errgroups‚Äîlots of features to help you work with concurrency. Switching from JS to Go, it was a breath of fresh air and one of the main things that\u0026hellip;\nPerformance You probably were waiting for me to come to this topic; everyone talks about that. But for me, and maybe for most developers, it should be the least important. This is not why I use Go. Every company I worked for, every system I built, could have been built with other languages (even JS ü§¢). Most of us don‚Äôt count microseconds of performance.\nAnd we have lots of benchmarks all over the internet stating that language X is better than language Y. And most of these benchmarks have shady methodology and lots of biases. A benchmark is a scientific research; it must have a well-defined plan and consider its limitations. There are numerous situations to test, numerous structures and algorithms that these tests will never touch. There are compilation and interpretation improvements that can happen if you run the same code more than once. Maybe a language has a faster encoding of JSON, but another is faster for decoding because of the implementation in each one. And usually, the person comparing tech A to tech B is an expert with A and has a basic understanding of B; of course, it‚Äôs easier for them to extract more performance from A.\nBut yeah, Go is fast, and you can build your web server; it will handle your load. You probably don‚Äôt need Rust or Zig for it. Remember that the language is just part of your latency; usually, we have lots of components on the way‚Äîcontainer clusters, lots of network hops, load balancers, API gateways, etc.\nSummary Of course, there are things I don‚Äôt like in Go, like the built-in make, more specifically its signature func make(t Type, size ...IntegerType) Type. It‚Äôs not clear what the possible parameters are, and for different data structures, the behaviour is different. I always get confused when using it. I will not dive into the problems; that‚Äôs not the point now (maybe in another post).\nAt the end, the main things that make me love Golang are its ease of use, simplicity, and community. I don‚Äôt have a problem changing programming languages at work, but if I had to choose, I would prefer to stick with it, at least for now. We see more and more Golang jobs opening each year and more devs starting their journey learning Go. Remember, Go is a general-purpose language. We usually see APIs and CLIs being built with Go, but it‚Äôs possible to serve SPAs, run WebAssembly code generated from Go, and deal with AI stuff. Go is still v1. The future ahead is bright and exciting.\n","permalink":"https://blog.o-mago.com/posts/should-i-stay-or-should-i-go/","summary":"\u003cp\u003eLet\u0026rsquo;s talk about why Go is so interesting and why I love it!\u003c/p\u003e\n\u003cp\u003eIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\u003c/p\u003e","title":"Should I Stay or Should I Go?"},{"content":"","permalink":"https://blog.o-mago.com/posts/","summary":"posts","title":"Posts"}]