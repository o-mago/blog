[{"content":"Have you ever got confused about testing functions using time.Now()? What about functions calling goroutines?\nWell your problems are over‚Ä¶ or they will be over with Go 1.25, that will be released soon (probably next month) featuring the new testing/synctest package\nWhat does synctest do? Basically, it allows you to run your tests in a ‚Äúbubble‚Äù, a kind of isolation from the rest of the test.\nIt‚Äôs meant to make your life easier when testing concurrent code, avoiding flaky tests, changing your production code to be testable, and reducing the time to run tests.\nThis bubble has two main features:\nA fake clock A blocking mechanism for goroutines It has two exported functions (actually three, but one is already deprecated üò≤; we‚Äôll discuss this more in a bit):\nfunc Test(t *testing.T, f func(*testing.T)) func Wait() Test creates what we call a ‚Äúbubble.‚Äù It‚Äôs the function that allows you to stop the clock in the past and control its flow as if you were the Flash running so fast ‚ö°. It waits until all goroutines have returned and will also make the test fail if any goroutine becomes deadlocked. It‚Äôs a way to even detect goroutine leaks.\nWait will wait until all goroutines get into a state called ‚Äúdurably blocked.‚Äù This means waiting until they have already finished or are blocked and won‚Äôt keep running unless an event is triggered by another goroutine inside the bubble to unblock them. I know it‚Äôs a bit confusing, but we‚Äôll see an example soon.\nThe fake clock The time.Now() will return midnight UTC 2000-01-01, meticulously chosen to remind us about the fears of the year 2000 problem, or millennium bug ü§™. And time won‚Äôt advance until all goroutines inside the bubble are blocked, for example, by using a time.Sleep to block them. It‚Äôs so much easier to control time this way, instead of having to rely on random sleep times and creating flaky tests.\nI used to do things like this:\nvar _now = time.Now func TimeToSendMessage(fallbackTime time.Time) time.Time { now := _now() if now.Hour() \u0026gt; 9 \u0026amp;\u0026amp; now.Hour() \u0026lt; 18 { return now } return fallbackTime } This code basically returns the time to send a message (SMS or something like this). We don‚Äôt want to bother our clients by sending messages outside business hours, so we check the hour of our current day. If we are before 9 a.m. or after 6 p.m., the system schedules a message for a fallback time.\nFocus on the _now variable. I created it to hold the function time.Now, because this way I would be able to ‚Äúmock‚Äù the time.Now like this:\nfunc TestTimeToSendMessage(t *testing.T) { inputTime := time.Date(2025, 10, 8, 12, 0, 0, 0, time.UTC) tt := []struct { name string mockedNow time.Time expected time.Time }{ { name: \u0026#34;should return now\u0026#34;, mockedNow: time.Date(2025, 5, 8, 12, 0, 0, 0, time.UTC), expected: time.Date(2025, 5, 8, 12, 0, 0, 0, time.UTC), }, { name: \u0026#34;should return fallback time\u0026#34;, mockedNow: time.Date(2025, 5, 8, 20, 0, 0, 0, time.UTC), expected: inputTime, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { _now = func() time.Time { return tc.mockedNow } result := TimeToSendMessage(inputTime) if result != tc.expected { t.Fatalf(\u0026#34;wrong output\u0026#34;) } }) } } I always felt dirty doing things this way. We have some problems here:\nWe can‚Äôt run these test cases in parallel; we would have a data race since we are reassigning the value of _now, and our tests would be flaky. I had to add more code, complexity, and ugliness to the production code in order to test it. Now my problems are over; I can just do the following:\nfunc TimeToSendMessage(fallbackTime time.Time) time.Time { now := time.Now() if now.Hour() \u0026gt; 9 \u0026amp;\u0026amp; now.Hour() \u0026lt; 18 { return now } return fallbackTime } func TestTimeToSendMessage(t *testing.T) { inputTime := time.Date(2025, 10, 8, 12, 0, 0, 0, time.UTC) tt := []struct { name string sleepDuration time.Duration expected time.Time }{ { name: \u0026#34;should return now\u0026#34;, sleepDuration: 12 * time.Hour, expected: time.Date(2000, 1, 1, 12, 0, 0, 0, time.UTC), }, { name: \u0026#34;should return fallback time\u0026#34;, sleepDuration: 0, expected: inputTime, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Run(func() { time.Sleep(tc.sleepDuration) // time.Now() will add this sleep time result := TimeToSendMessage(inputTime) if !result.Equal(tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) }) } } This way, I don‚Äôt have to change production code, and I can run the tests in parallel without worries.\nIf you don‚Äôt believe me, here‚Äôs the code.\nBlocking mechanism for goroutines I‚Äôve already explained the Wait function; let‚Äôs go to an example.\nImagine a function DoSomething that basically receives a string and returns a string pointer. The pointer will default to the initialString address (and value). But we have a goroutine inside that will change the value of the pointer to \u0026quot;test\u0026quot; if the initialString has the value \u0026quot;returnTest\u0026quot;.\nHere‚Äôs the code and the test:\nfunc DoSomething(initialString string) *string { strPointer := \u0026amp;initialString go func() { if initialString != \u0026#34;returnTest\u0026#34; { return } *strPointer = \u0026#34;test\u0026#34; }() return strPointer } func TestDoSomething(t *testing.T) { tt := []struct { name string input string expected string }{ { name: \u0026#34;should return \u0026#39;any\u0026#39; pointer\u0026#34;, input: \u0026#34;any\u0026#34;, expected: \u0026#34;any\u0026#34;, }, { name: \u0026#34;should return \u0026#39;test\u0026#39; pointer\u0026#34;, input: \u0026#34;returnTest\u0026#34;, expected: \u0026#34;test\u0026#34;, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { result := DoSomething(tc.input) if *result != tc.expected { t.Fatalf(\u0026#34;wrong result %s\u0026#34;, *result) } }) }) } } First, we don‚Äôt have a synctest.Wait() call, as you can see, and the output of our code is the following:\n=== RUN TestDoSomething === RUN TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === RUN TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer prog_test.go:50: wrong result returnTest --- FAIL: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer (0.00s) --- FAIL: TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer (0.00s) FAIL It failed. That‚Äôs because we are not waiting for all the goroutines to become ‚Äúdurably blocked.‚Äù Changing our test:\nfunc TestDoSomething(t *testing.T) { tt := []struct { name string input string expected string }{ { name: \u0026#34;should return \u0026#39;any\u0026#39; pointer\u0026#34;, input: \u0026#34;any\u0026#34;, expected: \u0026#34;any\u0026#34;, }, { name: \u0026#34;should return \u0026#39;test\u0026#39; pointer\u0026#34;, input: \u0026#34;returnTest\u0026#34;, expected: \u0026#34;test\u0026#34;, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { result := DoSomething(tc.input) synctest.Wait() if *result != tc.expected { t.Fatalf(\u0026#34;wrong result %s\u0026#34;, *result) } }) }) } } The new output will be:\n=== RUN TestDoSomething === RUN TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === RUN TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === PAUSE TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer === CONT TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer --- PASS: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;any\u0026#39;_pointer (0.00s) --- PASS: TestDoSomething/should_return_\u0026#39;test\u0026#39;_pointer (0.00s) PASS Goroutine Leaks I will not dive too much into this subject‚Äîmaybe it deserves a proper post. But the synctest package can be used to detect goroutine leaks. Goroutine what???\nIt‚Äôs similar to the idea of memory leaks‚Äîa goroutine that‚Äôs stuck and should have already ended.\nIt can happen for different reasons, but one of them is unbuffered channels and early returns.\nvar ( ErrorProcess = errors.New(\u0026#34;process error\u0026#34;) ErrorRequest = errors.New(\u0026#34;request error\u0026#34;) ) func DoSomething(input string) error { c := make(chan error) go func() { c \u0026lt;- process() }() if err := request(input); err != nil { return err } err := \u0026lt;-c return err } func process() error { time.Sleep(2 * time.Second) return ErrorProcess } func request(input string) error { time.Sleep(1 * time.Second) if input == \u0026#34;error\u0026#34; { return ErrorRequest } return nil } Let‚Äôs give an example. Imagine a function where you have an error channel and you process some stuff on a goroutine; if any error happens, you produce an error in the channel. Then you do some request, and after, you consume the error from the channel in order to return it. But if this request in the middle fails, it will return, and the consumer will vanish faster than beer near me. As we already know (or maybe you are learning here üòÑ), unbuffered channels must have active producers and consumers. In this case, we have lost the consumer, so the producer will stall and block our goroutine. There‚Äôs your leak.\nWhen we try to test it without synctest, we get:\nfunc TestDoSomethingNoSynctest(t *testing.T) { tt := []struct { name string input string expected error }{ { name: \u0026#34;should return process error\u0026#34;, input: \u0026#34;ok\u0026#34;, expected: ErrorProcess, }, { name: \u0026#34;should return request error\u0026#34;, input: \u0026#34;error\u0026#34;, expected: ErrorRequest, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() err := DoSomething(tc.input) if !errors.Is(err, tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) } } === RUN TestDoSomethingNoSynctest === RUN TestDoSomethingNoSynctest/should_return_process_error === PAUSE TestDoSomethingNoSynctest/should_return_process_error === RUN TestDoSomethingNoSynctest/should_return_request_error === PAUSE TestDoSomethingNoSynctest/should_return_request_error === CONT TestDoSomethingNoSynctest/should_return_process_error === CONT TestDoSomethingNoSynctest/should_return_request_error --- PASS: TestDoSomethingNoSynctest (0.00s) --- PASS: TestDoSomethingNoSynctest/should_return_request_error (1.00s) --- PASS: TestDoSomethingNoSynctest/should_return_process_error (2.00s) PASS Oh! Beautiful, my code works, it‚Äôs perfect‚Ä¶ ewwww, not actually‚Ä¶ Running my test with synctest:\nfunc TestDoSomething(t *testing.T) { tt := []struct { name string input string expected error }{ { name: \u0026#34;should return process error\u0026#34;, input: \u0026#34;ok\u0026#34;, expected: ErrorProcess, }, { name: \u0026#34;should return request error\u0026#34;, input: \u0026#34;error\u0026#34;, expected: ErrorRequest, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { t.Parallel() synctest.Test(t, func(t *testing.T) { err := DoSomething(tc.input) if !errors.Is(err, tc.expected) { t.Fatalf(\u0026#34;wrong result\u0026#34;) } }) }) } } === RUN TestDoSomething === RUN TestDoSomething/should_return_process_error === PAUSE TestDoSomething/should_return_process_error === RUN TestDoSomething/should_return_request_error === PAUSE TestDoSomething/should_return_request_error === CONT TestDoSomething/should_return_process_error === CONT TestDoSomething/should_return_request_error --- FAIL: TestDoSomething (0.00s) --- PASS: TestDoSomething/should_return_process_error (0.00s) --- FAIL: TestDoSomething/should_return_request_error (0.00s) panic: deadlock: main bubble goroutine has exited but blocked goroutines remain [recovered, repanicked] goroutine 18 [running]: testing.tRunner.func1.2({0x567da0, 0xc000212000}) /usr/local/go-faketime/src/testing/testing.go:1872 +0x237 testing.tRunner.func1() /usr/local/go-faketime/src/testing/testing.go:1875 +0x35b panic({0x567da0?, 0xc000212000?}) /usr/local/go-faketime/src/runtime/panic.go:783 +0x132 internal/synctest.Run(0xc00018e000) /usr/local/go-faketime/src/runtime/synctest.go:251 +0x2de testing/synctest.Test(0xc000118380, 0xc00018c000) /usr/local/go-faketime/src/testing/synctest/synctest.go:282 +0x90 play.TestDoSomething.func1(0xc000118380) /tmp/sandbox4287699162/prog_test.go:67 +0x94 testing.tRunner(0xc000118380, 0xc000104040) /usr/local/go-faketime/src/testing/testing.go:1934 +0xea created by testing.(*T).Run in goroutine 7 /usr/local/go-faketime/src/testing/testing.go:1997 +0x465 goroutine 35 [sleep (durable), synctest bubble 2]: time.Sleep(0x77359400?) /usr/local/go-faketime/src/runtime/time.go:361 +0x12c play.process(...) /tmp/sandbox4287699162/prog_test.go:31 play.DoSomething.func1() /tmp/sandbox4287699162/prog_test.go:20 +0x25 created by play.DoSomething in goroutine 34 /tmp/sandbox4287699162/prog_test.go:19 +0x6b Program exited. This happens because we still have a blocked goroutine at the end of the synctest bubble. The output is a little bit confusing, I know, but there‚Äôs another alternative for it: the goleak package by Uber.\nThe 3rd function I said that there were actually three exported functions inside this package (at least at the time of this post). That‚Äôs because this package was first introduced as an experimental package with Go 1.24. This way, you can already preview this new change now‚Äîif your code is not stuck in an older Go version üëÄ.\nThe examples I gave used the new Go 1.25 API. It‚Äôs possible to test it easily by downloading the release candidates or using the Go Playground and selecting the Go dev branch version in the dropdown. Be aware with every experimental feature because the API can change. Quoting the release notes:\nThe package API is subject to change in future releases\nGo 1.24 release notes\nLet‚Äôs first take a look at the differences between them:\nGo 1.24:\nfunc Run(f func())\nfunc Wait()\nGo 1.25:\nfunc Run(f func())\nfunc Test(t *testing.T, f func(*testing.T))\nfunc Wait()\nAs we can see, the Wait and Run functions haven‚Äôt changed. The only change is the addition of Test. But it was actually made to replace Run. In the docs, you can read:\nfunc Run(f func()) Run is deprecated. Deprecated: Use Test instead. Run will be removed in Go 1.26. Their core functionality is the same, as we can see in the source code. They both call synctest.Run:\nfunc Run(f func()) { synctest.Run(f) } func Test(t *testing.T, f func(*testing.T)) { var ok bool synctest.Run(func() { ok = testingSynctestTest(t, f) }) if !ok { // Fail the test outside the bubble, // so test durations get set using real time. t.FailNow() } } But the change was not only the name‚Äîthe parameters are different, and Test calls testingSynctestTest, which is important. Let‚Äôs understand a little bit more about what happened here.\nThey added the t *testing.T parameter, and testingSynctestTest will basically create a new t2 *testing.T based on t. But why?\nSo T.Cleanup calls can run inside the bubble at the end of the synctest.Test function, and T.Context can return a cancellable context with a Done channel in the bubble.\nYou can see more examples about synctest in the Go blog‚Äîit was based on the experimental Go 1.24 version, but it‚Äôs pretty similar to what you can do with Go 1.25 using Test instead of Run. You can also check the package reference.\nAnd that‚Äôs all folks, thanks for your attention, hope you enjoyed ü§ò\nAnd what about you? Are you using synctest already?\n","permalink":"https://blog.o-mago.com/posts/concurrent-code-testing-with-synctest-bubbles-in-go/","summary":"\u003cp\u003eHave you ever got confused about testing functions using \u003ccode\u003etime.Now()\u003c/code\u003e? What about functions calling goroutines?\u003c/p\u003e\n\u003cp\u003eWell your problems are over‚Ä¶ or they will be over with Go 1.25, that will be released soon (probably next month) featuring the new \u003ccode\u003etesting/synctest\u003c/code\u003e package\u003c/p\u003e\n\u003ch3 id=\"what-does-synctest-do\"\u003eWhat does synctest do?\u003c/h3\u003e\n\u003cp\u003eBasically, it allows you to run your tests in a ‚Äúbubble‚Äù, a kind of isolation from the rest of the test.\u003c/p\u003e\n\u003cp\u003eIt‚Äôs meant to make your life easier when testing concurrent code, avoiding flaky tests, changing your production code to be testable, and reducing the time to run tests.\u003c/p\u003e","title":"Concurrent code testing with synctest bubbles in Go"},{"content":"Let\u0026rsquo;s talk about why Go is so interesting and why I love it!\nIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\n‚ÄúGo‚Äù by Pearl Jam, ‚ÄúGo‚Äù by Blink-182, ‚ÄúGo‚Äù by Indigo Girls, ‚ÄúGo‚Äù by Kelly Clarkson, \u0026ldquo;Go\u0026rdquo; by The Smashing Pumpkins, \u0026ldquo;Go\u0026rdquo; by Def Leppard, \u0026ldquo;Go Go Go\u0026rdquo; by Chuck Berry, ‚ÄúHere I Go Again‚Äù by Whitesnake, ‚ÄúGo All the Way‚Äù by Raspberries, ‚ÄúGo Your Own Way‚Äù by Fleetwood Mac ‚Ä¶ and the list goes on!\nAfter some consideration, I found out I had lost lots of time searching and listening to songs, and I decided to go ü§≠ with The Clash.\nBut it fits perfectly with the theme. I‚Äôm also a mentor at ADPList, and many of my mentees ask me this question from the title. Ok, not exactly like that, but like ‚ÄúShould I learn Go?‚Äù or ‚ÄúWhy do you like Go?‚Äù\nThe first question is hard to answer, but as a senior engineer, I have the answer: ‚ÄúIt depends.‚Äù Usually, I start asking, not answering, because it depends on each one\u0026rsquo;s reality. I will not dive into this question today (maybe in another post). Today I want to talk about the second one; maybe it helps you reflect on the first one and clear things up for you, maybe not.\nFirst I want to tell my story quickly: how I ended up working with Go, when it started and why I chose to keep going.\nHow it started My first contact with Golang was on a cold night (not that cold, this is Brazil) in September 2020. I was working with JavaScript at that time, I was unhappy (of course, it‚Äôs JS ü§™) and wanted to change jobs. A friend of mine was working in a company using Go and said they were looking for engineers, and wanted to refer me. I didn‚Äôt know Go at the time (just by name), but he said the language was great. I was unsure, but I accepted it and started the selection process.\nThe first step was a LeetCode-like challenge, but it wasn‚Äôt mandatory to use Go. But I wanted to show ‚ÄúI‚Äôm a fast learner,‚Äù so I took one day to study the documentation and did some basic LeetCode with it. I took the test the next day and passed. At that point, I knew I wasn‚Äôt that fast; actually, the language is ‚Äúfast learnable.‚Äù\nThese were the first characteristics of the language that I noticed:\n‚ÄúIt is fast to learn‚Äù ‚ÄúIt has amazing and intuitive documentation‚Äù At that point, I was convinced to give it a try if I got the job.\nI got the job, and then the more I dived into the language, tools, and the community, the more I fell in love with it. ‚ù§Ô∏è\nSo let‚Äôs break into these and other reasons why I fell in love.\nGreat Documentation Why is the documentation great?\nIt‚Äôs meant for learners. When you enter the Go documentation webpage, you don‚Äôt see lots of texts and references, etc. You see lots of links to resources for learning, tutorials, examples, good practices, guidelines, and explanations of the internals. It has resources for starters and for those who want to dive into the internals of Go, like how the garbage collector works. They make it easy for you to start using, but they want you to understand how Go works‚Äîreally understand what you are doing.\nOne of the main parts is the Learn Go section. It‚Äôs so amazing; it‚Äôs where I first learned Go, and that‚Äôs my suggestion to all my mentees and everyone that asks. I‚Äôm not a video tutorial fan, so I tend to prefer written material.\nIt tells you everything very straightforwardly, starting with how to install. Then you have the amazing Tour of Go, where it will teach you all the basics with split sections and interactive examples for you to run using the Go Playground. It‚Äôs great because many people get afraid when they see lots of texts, without a certain order‚Äîthey freeze. The ‚ÄúTour of Go‚Äù takes you by the hand in a linear path through the magical world of the Gopher, with compiled information, just what you need to get an idea of how everything works without letting your memory overflow. At the end, it gives you a ton of links to deep dive into some subjects, like concurrency, and some more practical tutorials, like web servers and CLIs.\nYou also have Go by Example, which gives you a brief explanation and examples for common Go usage. It‚Äôs great because it has an index with the subject associated‚Äîsomething to help you remember some stuff without having to go through the tour all over again. These two are a great combo for starters. And if you want to expand more, there‚Äôs the Go Specification.\nAnd of course, you have the amazing ‚ÄúEffective Go,‚Äù a guideline to write idiomatic Golang. It‚Äôs a must-read. I know it‚Äôs long, like this blog post is becoming, but it‚Äôs worth your time.\nThe Release Notes are amazing, always summarizing the main changes in the language first, then they go tool by tool, package by package. It‚Äôs really made for humans to read, and it‚Äôs great as a guide to understand the impact on your code. You can easily look at each topic, see what can impact you, and test or change your code to use the newest modifications.\nAnd of course, we cannot forget the Standard Library Reference. It has all the packages, all the functions, methods, explanations, and examples. It‚Äôs amazing.\nFast to learn I experienced this and have heard from many others the same. Why?\nIt becomes pretty obvious after the last paragraphs I wrote about the documentation üòÑ. It really has a way to onboard you fast and let you dive into the language as you need and want.\nBut it‚Äôs not only that, there‚Äôs more‚Ä¶\nGo is simple Just looking at some data, Go is one of the mainstream languages with the fewest reserved words:\nJava: \u0026gt; 60 JavaScript: \u0026gt; 50 Rust: \u0026gt; 35 Python: \u0026gt; 30 Go: 25 How is that possible? A simple example that I like is that you don‚Äôt have while; you just use for without a condition. Do you want to make a function private? Just use lowercase.\nGo tries (almost always) to be concise, to have as few ways as possible of doing the same thing. It wants to give you tools (types, functions, methods) to allow you to build your logic, not to build everyone‚Äôs logic and package it. For example, we don‚Äôt have for and foreach like in JS. Of course, there are methods from the slices package to sort, compare, and we have iterators now. But all of them have their purpose; it‚Äôs not simply a way to avoid creating an i variable in the for loop. You could argue that in Go there is the range to do something similar to what foreach does. But it has more specific uses, like ranging over channels.\nBecause of this simplicity, Go is easy to read‚Äîeven the standard library internal code. They really do what they suggest you do. Go is humble; it doesn‚Äôt try to be unnecessarily clever and fancy, it just does the work. No classes, no inheritance, just composition.\nSimplicity has a strong relation with being explicit in this case, and sometimes it has its price: more code written, like in the case of error handling in Go. üò¨\nGo is reliable Go has the philosophy of backwards compatibility at all costs, avoiding breaking changes on major or minor versions. It happened in the past, of course‚Äîthere‚Äôs the famous loopvar change where they changed how the loop variable behaves. It was in many cases the root of bugs, but that‚Äôs because of a dissonance between the behaviour and what most people expected, and at the end, it was just behaviour. And the behaviour changed; maybe someone was relying on the way things were, and the fix actually caused a new bug. Who knows? Not me, I read the release notes every time. That‚Äôs why I always advise you to read them before updating your Go version, especially if it‚Äôs a major version.\nAlthough we don‚Äôt have an exact date of release of new Go versions, we can count on two major releases a year.\nGo improves Go is always seeking improvement in all areas: performance of the compiler, of the packages (like faster JSON encoding), and bringing new toys, like iterators and generics. I don‚Äôt know about you, but for me, all this effort to bring new features and improve things gets me excited like when a new video game console will be launched or a new Star Wars movie will be released (when they were good).\nI know much of this stuff is not new, like generics or PGO. But all of it is thought through carefully and discussed in the community before being merged. And I think Go and its community are an ecosystem that revives and brings light to some old tech in a way that people think it‚Äôs new. Because they do it in a developer-friendly way, like PGO. It was already a thing in C++ and other languages. But if you search PGO today, the majority of content, posts, and talks will be related to Golang.\nGo is an ecosystem Golang is more than a language; it is a Swiss Army knife. When you install it from the official website, you get a powerful tool with the capabilities of:\ntesting (test) building (build) formatting and fixing mistakes (fmt, vet) managing modules (mod) managing dependencies (get) analyzing profiles (tool pprof) And benchmarking, outputting test coverage, and much more‚Ä¶\nIt‚Äôs all accessible out of the box with the command line go \u0026lt;command\u0026gt;. You don‚Äôt have to install different tools to start coding and maintaining your code. Of course, there are some third-party tools that can help you along the way, like golangci-lint.\nThe Community This is another great point: Golang has an active community of enthusiasts. You have official channels for it‚ÄîSlack, Google Groups‚Äîand even the Go repository is a great place to get involved in discussions inside the issues. You can point out improvements or bugs and collaborate through pull requests.\nThere are tons of Golang groups and conferences, and I see more and more starting. Here in Brazil, we have meetups like Golang SP, Floripa Gophers, and many GDGs around the country talk about Golang. Of course, there are the main conferences all over the globe, like Gophercon Latam, Golab, Gophercon US, Gophercon UK, etc. And many other conferences have some space for Golang talks, especially DevOps ones, like DevOps Days and Container Days. And there‚Äôs space for beginners and experts; every conference I attended, people are nice and open to help someone that‚Äôs struggling to start with the language.\nLet‚Äôs not forget the newsletters. We have the Golang Weekly and, for the Portuguese speakers, thanks to Elton Minetto, there is A Semana Go. This way, you can always keep up to date with news about the language and interesting projects.\nI know not everyone wants to think about programming after work, but if you want and enjoy it, there are so many resources and people that share the same feeling and excitement about Go.\nAsynchronous made easy Go has eliminated the distinction between synchronous and asynchronous code.\nBob Nystrom\nThis statement is strong and impactful. I really recommend this post.\nGolang is amazing because it is built with goroutines, even the main one. Each goroutine is a user-level thread managed by the Go runtime, using a pool of OS threads. The way it works enables avoiding all the async-await hell. Any function can become asynchronous with the keyword go; you don‚Äôt have a chain of changes over the functions that are calling it.\nWe also have the usage of channels, the select statement, mutexes, waitgroups, errgroups‚Äîlots of features to help you work with concurrency. Switching from JS to Go, it was a breath of fresh air and one of the main things that\u0026hellip;\nPerformance You probably were waiting for me to come to this topic; everyone talks about that. But for me, and maybe for most developers, it should be the least important. This is not why I use Go. Every company I worked for, every system I built, could have been built with other languages (even JS ü§¢). Most of us don‚Äôt count microseconds of performance.\nAnd we have lots of benchmarks all over the internet stating that language X is better than language Y. And most of these benchmarks have shady methodology and lots of biases. A benchmark is a scientific research; it must have a well-defined plan and consider its limitations. There are numerous situations to test, numerous structures and algorithms that these tests will never touch. There are compilation and interpretation improvements that can happen if you run the same code more than once. Maybe a language has a faster encoding of JSON, but another is faster for decoding because of the implementation in each one. And usually, the person comparing tech A to tech B is an expert with A and has a basic understanding of B; of course, it‚Äôs easier for them to extract more performance from A.\nBut yeah, Go is fast, and you can build your web server; it will handle your load. You probably don‚Äôt need Rust or Zig for it. Remember that the language is just part of your latency; usually, we have lots of components on the way‚Äîcontainer clusters, lots of network hops, load balancers, API gateways, etc.\nSummary Of course, there are things I don‚Äôt like in Go, like the built-in make, more specifically its signature func make(t Type, size ...IntegerType) Type. It‚Äôs not clear what the possible parameters are, and for different data structures, the behaviour is different. I always get confused when using it. I will not dive into the problems; that‚Äôs not the point now (maybe in another post).\nAt the end, the main things that make me love Golang are its ease of use, simplicity, and community. I don‚Äôt have a problem changing programming languages at work, but if I had to choose, I would prefer to stick with it, at least for now. We see more and more Golang jobs opening each year and more devs starting their journey learning Go. Remember, Go is a general-purpose language. We usually see APIs and CLIs being built with Go, but it‚Äôs possible to serve SPAs, run WebAssembly code generated from Go, and deal with AI stuff. Go is still v1. The future ahead is bright and exciting.\n","permalink":"https://blog.o-mago.com/posts/should-i-stay-or-should-i-go/","summary":"\u003cp\u003eLet\u0026rsquo;s talk about why Go is so interesting and why I love it!\u003c/p\u003e\n\u003cp\u003eIt took me some time to choose the title of the post. I wanted to play with a song name; the first one that came to my mind was ‚ÄúShould I Stay or Should I Go?‚Äù by The Clash, a classic. But then my curiosity made me search for other songs with the word ‚Äúgo.‚Äù And there are a lot.\u003c/p\u003e","title":"Should I Stay or Should I Go?"},{"content":"","permalink":"https://blog.o-mago.com/posts/","summary":"posts","title":"Posts"}]